task,prompt,iteration,response,word count,repetition,completeness,correctness,feedback type,concepts,missing,additional
0,"Explain following programming task: ""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""",1,"This programming task involves creating a Python 3.x program which prompts the user for a bank code (Bankleitzahl) and an account number (Kontonummer) and output the complete IBAN, including the checksum. The program should also prompt for a country code (e.g. DE for Germany) if desired, though for beginners it is sufficient to hardcode the country code ""DE"" as an input. 

The program should also take into account the calculation guidelines for calculating the checksum as per the provided link, ensuring that the output is accurate.

The user should be adequately informed of what inputs are expected and their significance, both in the form of prompts and output messages. Comments should also be used in the code to improve structure and readability. The program should also address in the documentation which inputs are not allowed and may lead to error messages (if not already handled).",147,125,{},1,"KC,KH,KTC","input/output handling,documentation,comments","variables,string manipulation",
0,"Explain following programming task: ""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""",2,"This programming task requires the creation of a Python 3.x program that takes two inputs from the user: a bank code (Bankleitzahl) and an account number (Kontonummer). The program should then calculate and return the complete IBAN (International Bank Account Number) based on the inputs provided, including the checksum. The hardcoded country code should be ""DE"" but if desired, the program can also prompt for the country code.

Additional guidelines or requirements include: ensuring that input prompts clearly explain to the user what should be entered and the significance of the entered data; using comments in the code in order to improve structure and readability; and informing the user in the documentation of which inputs are not allowed and may lead to error messages (if not already handled). Instructions for calculating the checksum can be found at the provided URL.",141,115,{},1,"KC,KH,KTC,KMC","input/output handling,documentation,comments","variables,string manipulation",
0,"Explain following programming task: ""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""",3,"This programming task requires creating a Python 3.x program that prompts the user for a Bankleitzahl, Kontonummer, and if desired, a country code. The program should then produce the International Bank Account Number (IBAN) which consists of a country code, two-digit checksum, and a basic Bank Account Number. To generate the checksum the instructions found at the website https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits can be used and a hardcoded DE for the country code is sufficient, but prompting for the country code as additional input is an option. It is also important to ensure that the input prompts clearly explain what the user should enter and what its significance is, as well as output messages with the resulting IBAN. Additionally, the code needs to be structured and commented to improve readability, and in the documentation, describe which inputs are not allowed and may cause error messages.",150,120,{},1,"KH,KTC,KC","input/output handling,documentation,comments","variables,string manipulation",
1,"Explain following programming task: ""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""",1,"This programming task requires the creation of a Python 3.x program which reads an inputted year from the console and determines whether it is a leap year. To do this, the program must utilize the rules of the Gregorian calendar which states that leap years occur on any year that is divisible by 4, however, if the year is also divisible by 100, then it is not a leap year unless it is also divisible by 400. The result should be displayed in the console as a complete sentence in the form of ""The year [year] is [not] a leap year."" For example, the output for the year 1993 would be ""The year 1993 is not a leap year."" and the output for the year 2024 would be ""The year 2024 is a leap year.""",136,93,{},1,"KC,KH","input/output handling,conditionals,string manipulation",variables,
1,"Explain following programming task: ""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""",2,"This program should first prompt the user to enter a year in the console. Then, it should analyze the year against the rules of the Gregorian calendar (divisible by 4 but not by 100 unless divisible by 400). After assessing if the year is a leap year, the program should display the result in the console as a complete sentence. For example, it should say either ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""",82,52,{},1,"KC,KH","input/output handling,conditionals","variables,string manipulation",
1,"Explain following programming task: ""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""",3,"This programming task requires you to create a python program that takes an integer year value as input from the console and then determines whether the year is a leap year or not based on the rules of the Gregorian calendar. If the year is a leap year, the program should output a sentence to the console stating the year is a leap year, such as ""The year 2024 is a leap year."" If the year is not a leap year, the program should output a sentence to the console stating the year is not a leap year, such as ""The year 1993 is not a leap year.""",108,88,{},1,"KC,KTC","input/output handling,conditionals","variables,string manipulation",
2,"Explain following programming task: ""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""",1,"This programming task requires the development of a Python 3.x program that takes a user input to determine whether to calculate the number of Friday the 13th occurrences in a leap year or a non-leap year. The program should then use this input to perform the calculations and display clear and understandable output. Utilizing the Python 3.10 match-case feature would be helpful for this program as it will make the code easier to follow and understand. The program must also take into account the weekday on which the year starts in order to calculate the correct amount of occurrences for a given year. In the end, the program should be able to display the minimum and maximum amount of Friday the 13th occurrences for the given type of year.",133,103,{},1,"KC,KH,KTC","input/output handling,conditionals","variables,string manipulation,loops",
2,"Explain following programming task: ""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""",2,"This program should use Python 3.x and will require the user to enter whether they are calculating for a leap year or a non-leap year. The program should then calculate the minimum and maximum number of ‘Friday the 13th’ occurrences depending on the type of year selected. In particular, it should take into account the weekday on which the year starts; this will determine the minimum and maximum number of ""Friday the 13th"" occurrences. 

The program should also take advantage of the new match-case feature in Python 3.10 to allow for clear and understandable output when the user has supplied their input. Finally, the program should provide clear and understandable output with the calculated minimum and maximum ‘Friday the 13th’ occurrences for the selected year type.",130,101,{},1,"KC,KH","input/output handling,conditionals","variables,string manipulation,loops",
2,"Explain following programming task: ""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""",3,"This programming task involves creating a Python 3.x program that can calculate the number of ""Friday the 13th"" occurrences in a given year. The user should be able to specify whether they want to calculate for a leap year or not. The program should provide clear and understandable output.

To achieve this program, we can first use the new match-case feature in Python 3.10 to determine the weekday on which the year will begin. This will determine how many ""Friday the 13th"" occurrences there will be in a year. For example, if January 1st is a Tuesday, then there will be three Friday the 13th's for that year.

Next, we can write a simple if-else statement to determine whether the given year is a leap year or not. Depending on the user's input, the program can calculate the number of Friday the 13th's for either a leap year or non-leap year. 

Finally, the program should output a clear and understandable result. It should display the minimum and maximum number of Friday the 13th's for that given year based on the user's input.",192,147,{},1,"KH,KC","input/output handling,conditionals","variables,string manipulation,loops",
3,"Explain following programming task: ""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""",1,"#Solution

#a)
def chessboard():
  print(""   A   B   C   D   E   F   G   H"")
  for num in range(1,9):
    print("" ""+str(num)+""  "",end="""")
    for letter in [""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H""]:
      print("" ""+letter+str(num)+"" "",end="""")
    print(""\n"")

chessboard()

#b)
def queen_on_chessboard(position):
  print(""   A   B   C   D   E   F   G   H"")
  for num in range(1,9):
    print("" ""+str(num)+""  "",end="""")
    for letter in [""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H""]:
      if letter+str(num) == position:
        print("" ♛  "",end="""")
      else:
        print("" ""+letter+str(num)+"" "",end="""")
    print(""\n"")

queen_on_chessboard(""B4"")",93,61,{},0: “no default parameter in b)”,Solution,"functions,loops,conditionals,string manipulation",input/output handling,
3,"Explain following programming task: ""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""",2,"A)
def chessboard():
    for row in range(1, 9):
        print(""-------"")
        for col in range(1, 9):
            square_id = chr(col+64) + str(row)
            print(""|"", square_id, end="" "")
        print(""|"")
    print(""-------"")
 
chessboard()

B)
def queen_on_chessboard(position=None):
    for row in range(1, 9):
        print(""-------"")
        for col in range(1, 9):
            square_id = chr(col+64) + str(row)
            if position is not None and position == square_id:
                print(""|"", ""♛"" + "" "", end="""")
            else:
                print(""|"", square_id + "" "", end="""")
        print(""|"")
    print(""-------"")
 
queen_on_chessboard(position=""B4"")",71,40,{},1,Solution,"functions,loops,conditionals,string manipulation",input/output handling,
3,"Explain following programming task: ""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""",3,"a)
def chessboard():
    # Create an 8x8 grid
    grid = [["""" for x in range(8)] for y in range(8)] 
    
    # Populate the grid with square labels
    for y in range(0,8):
        for x in range(0,8):
            grid[y][x] = (chr(x + 65) + str(y + 1))

    # Print the grid
    for y in range(0,8):
        for x in range(0,8):
            if x == 7:
                print(grid[y][x])
            else:
                print(grid[y][x], end="" | "")

# Call chessboard function
chessboard()

b)
def queen_on_chessboard(position):
    # Create an 8x8 grid
    grid = [["""" for x in range(8)] for y in range(8)] 
    
    # Populate the grid with square labels
    for y in range(0,8):
        for x in range(0,8):
            grid[y][x] = (chr(x + 65) + str(y + 1))

    # Parse the parameter ""position""
    column = ord(position[0]) - 65
    row = int(position[1]) - 1

    # Replace the corresponding cell with a queen symbol
    grid[row][column] = 'QQ'

    # Print the grid
    for y in range(0,8):
        for x in range(0,8):
            if x == 7:
                print(grid[y][x])
            else:
                print(grid[y][x], end="" | "")

# Call queen_on_chessboard function
queen_on_chessboard('B4')",182,118,{},0: “no default parameter in b)”,Solution,"functions,loops,string manipulation,variables,conditionals,lists",input/output handling,"variables,lists"
4,"Explain following programming task: ""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""",1,"import random 

def show_matchsticks(remaining):
  print(""Remaining Matchsticks: "")
  for i in range(remaining):
  	print(""|"", end="""")
  print("""")

def console_input(prompt):
  userInput = input(prompt)
  return userInput

def pick_matchsticks(remaining):
  if remaining > 0:
    player = random.choice([1,2])
    
    if player == 1:
        prompt = ""Player 1, choose 1-3 matchsticks: ""
        matchsticks = console_input(prompt)
        while (not matchsticks.isdigit() or int(matchsticks) > 3 
               or int(matchsticks) > remaining):
            print(""Invalid number! Please enter a valid number between 1 and 3."")
            matchsticks = console_input(prompt)
        remaining = max(remaining - int(matchsticks), 0)
        show_matchsticks(remaining)
    else:
        prompt = ""Player 2, choose 1-3 matchsticks: ""
        matchsticks = console_input(prompt)
        while (not matchsticks.isdigit() or int(matchsticks) > 3 
               or int(matchsticks) > remaining):
            print(""Invalid number! Please enter a valid number between 1 and 3."")
            matchsticks = console_input(prompt)
        remaining = max(remaining - int(matchsticks), 0)
        show_matchsticks(remaining)
       
    return remaining
 
def game_start_init():
  remaining = 13
  while remaining > 0:
    remaining = pick_matchsticks(remaining)
    
  if remaining == 0:
    if player == 1:
      print(""Player 2 has won!"")
    else:
      print(""Player 1 has won!"")
 
game_start_init()",159,76,{},0: “random player choice.”,Solution,"functions,loops,input/output handling,string manipulation,variables,conditionals,randomness",,"variables,randomness"
4,"Explain following programming task: ""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""",2,"def printMatchsticks(number): 
  # Loop through the number parameter
  for i in range(number): 
    print(""|"", end="""") 
  # Print a new line 
  print() 
  
# Initializing the number of Matchsticks 
number = 13
  
# Since it's player 1's turn to play 
turn = 1

# Variable to check if the game is over 
game_over = False
  
# Loop until the game is over 
while game_over == False: 
  print(""Player"", turn, ""turn:"", end="""") 
  printMatchsticks(number) 
  
  # Ask player to take 1, 2, or 3 matchsticks 
  choice = int(input(""Choose how many sticks to take (1-3): ""))
    
  # Player cannot choose more than 3 sticks or less than 1 
  while choice > 3 or choice < 1: 
    choice = int(input(""Choose how many sticks to take (1-3): "")) 
  
  number -= choice 
  
  # If all the sticks are taken by any of the player, game is over 
  if number == 0: 
    game_over = True
      
  # Switch to other player 
  if turn == 1: 
    turn = 2 
  else: 
    turn = 1
  
# Print the winner 
if turn == 1: 
  print(""Player 1 won!"") 
else: 
  print(""Player 2 won!"")",160,83,{},0: “negative number and infinite loop possible.”,Solution,"functions,loops,input/output handling,comments,variables,conditionals",string manipulation,"comments,variables"
4,"Explain following programming task: ""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""",3,"This programming task can be implemented in Python 3.X to create a game of matchsticks. We will first create a function for visualizing the matchsticks with suitable output in the console. This function will take the number of remaining matchsticks as a parameter and will design and display the output visually. The main game will handle the logic of prompting the two players to take turns removing one, two, or three matchsticks. The game will continue until one of the players takes the last matchstick, in which case the program will display which player has won.",97,82,{},1,"KC,KH,KTC","functions,loops,input/output handling,conditionals",string manipulation,
5,"Explain following programming task: ""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""",1,"This programming task is about creating a module in Python 3.X called ""eprtools.py"" and implementing four functions within it. The first function, decimal_to_binary, takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console. The second function, exam_countdown, calculates the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. It displays the difference in the format ""_ days, _ hours, _ minutes"" in the console. The third function, open_course_page, takes a module abbreviation and opens the corresponding Moodle course or course webpage in a web browser, and returns True if a valid abbreviation is provided, otherwise returns False. The final function, password_gen, takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. After the module is created, a separate Python program should be coded which imports the module ""eprtools.py"" and allows the user to choose which of the four tools should be executed.",190,178,{},1,"KC,KH,KTC","functions,input/output handling,conditionals,modules,time,external resource,documentation","string manipulation,loops,randomness","time,external resource,documentation"
5,"Explain following programming task: ""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""",2,"This task is asking the programmer to create a module named ""eprtools.py"" and implement four functions within it.  The first function, called ""decimal_to_binary"", should take a positive integer as an argument and return a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console. The second function, named ""exam_countdown"", should calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM and display the difference in the console in the format ""_ days, _ hours, _ minutes"". If no timestamp is provided, use the current system timestamp. The third function, called ""open_course_page"", should take a module abbreviation as a parameter and open the corresponding Moodle course or course webpage in a web browser. The fourth function, named ""password_gen"", should take the parameter ""length"" and generate and returns a random password of the specified length.

Additionally, the task requires the programmer to create a separate Python 3.X program that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.",204,196,"{2: [""The constraint regarding time zones not needing to be taken into account for the 'exam_countdown' function is missing"", ""Password constraints missing.""]}",1,"KC,KTC","functions,input/output handling,string manipulation,variables,conditionals,randomness,modules,time,external resource,documentation",loops,"variables,time,external resource,documentation"
5,"Explain following programming task: ""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""",3,"This programming task requires two separate files: one containing the module ""eprtools.py"" and the other containing the program that imports the module. The ""eprtools.py"" module will contain four separate functions that perform specific tasks: a binary calculator, exam countdown, open course pages, and password generator. The first function, ""decimal_to_binary"", takes a positive integer as its argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console. The second function, ""exam_countdown"", calculates the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM, and then displays the difference in the console in the format ""_ days, _ hours, _ minutes"". If no timestamp is provided, the current system timestamp should be used. The third function, ""open_course_page"", takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"") as a parameter and opens the corresponding Moodle course or course webpage in a web browser. The fourth function, ""password_gen"", takes an integer parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. 

The second file contains a Python 3.X program that imports the ""eprtools.py"" module. The user should be able to choose which of the four implemented tools should be executed through console input. If necessary, any required parameters should be queried through the console.",239,218,"{2: ""The constraint regarding time zones not needing to be taken into account for the 'exam_countdown' function is missing""}",1,"KC,KH,KTC","functions,input/output handling,external resource,modules,time,documentation","string manipulation,conditionals,loops,randomness","external resource,time,documentation"
6,"Explain following programming task: ""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""",1,"This programming task involves creating functions to facilitate a memory game in Python. Task 1 involves creating functions to create a game grid, to flip two cards and reveal their motifs, to remove a card from the game grid, and to draw the game grid. Task 2 involves using the functions from the first task to implement the gameplay of the memory game. The game will involve shuffling the cards, drawing the game grid, the player choosing two cards, the cards being revealed for 3 seconds and then covered again, and if a pair is found, the cards are removed from the game grid. Once all pairs are found, the number of rounds required will be outputted and the player will have the option to start a new game. Additionally, the program will need to be able to handle incorrect user inputs without crashing.",144,127,{},1,"KC,KH,KTC","functions,loops,input/output handling,variables,modules,exception handling,time,lists","string manipulation,conditionals,randomness",variables
6,"Explain following programming task: ""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""",2,"This programming task involves creating a memory card game. The first task is to create a Python module named ""memory.py"" that will contain functions to facilitate the implementation of the game in the second task. The game is played with 20 cards, each one represented by a string with a corresponding symbol. The 20 cards are grouped together in a 5x4 grid. The function create_grid(cards) should arrange the cards in a grid nested list. The get_symbols(grid, pos1, pos2) function should reveal the motifs of the two cards and return them as a tuple. When a pair is revealed, the take_cards(grid, pos1, pos2) should adjust the current game grid so that the corresponding positions are marked as ""empty"". To display the game grid, the draw_grid(grid, pos1=None, pos2=None) function can be used.

In the second task, the game logic is implemented in a separate Python file. The cards are shuffled and arranged in a game grid and the player chooses two cards. If a pair is found, the cards are removed from the game grid. Once all pairs are found, the number of rounds required is output, followed by the option to start a new game. Care should be taken to ensure that the program handles incorrect user inputs without crashing.",216,193,{},1,"KC,KH,KMC","functions,loops,input/output handling,variables,conditionals,modules,exception handling,lists","string manipulation,randomness,time",variables
6,"Explain following programming task: ""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""",3,"This programming task involves creating a memory game in Python. The task consists of two parts: (1) preparations and (2) game logic. In the first part, functions should be created in a Python module that will make it easier to implement the game logic. This includes functions for creating the game grid, flipping cards, removing a card, and drawing the game grid. Once the functions are created, in the second part the gameplay should be coded. This should include shuffling the cards, creating the game grid, drawing the game grid, allowing the player to choose two cards, revealing the cards for 3 seconds and then covering them again, and removing the cards if a pair is found. Lastly, the program should output the number of rounds required and the player should have the option to start a new game. To make the program robust, it should be designed to handle incorrect user inputs without crashing.",155,123,{},1,"KC,KH,KTC","functions,loops,variables,modules,exception handling,lists","input/output handling,string manipulation,conditionals,randomness,time",variables
7,"Explain following programming task: ""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""",1,"This programming task requires the creation of a new Python module that will allow users to maintain a contact book stored in a list of dictionaries. The module must provide five functions that will allow the user to add, delete, edit, list, and show contacts from the contact book. The add_contact() function will take the contact book and the name of the contact to add as inputs, and will optionally accept additional parameters to add to the contact. The del_contact() functions takes the contact book and the name of the contact to delete as inputs. The edit_contact() function takes the contact book, the name of the contact, and the fields that need to be changed as inputs. Existing fields can be updated with this function, and new fields can be added. The list_contacts() function takes the contact book as input and will list all the contacts' names in the console. Finally, the show_contact() function takes the contact book and the name of the contact as inputs, and will display all the stored data for that contact in a formatted manner.",180,157,"{2: ""Does not explicitly mention the output for most functions.""}",1,"KC,KTC","functions,lists,dictionaries,(args/kwargs) arguments","input/output handling,conditionals,loops",
7,"Explain following programming task: ""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""",2,"This programming task involves creating a module in Python for a contact book using dictionaries and lists. The main functions created within this module are listed above. The add_contact() function takes the contact book as an input and adds a new contact. The del_contact() function takes the contact book and a name as input and removes the corresponding person from the contact book. The edit_contact() function takes the contact book, a name, and the fields to be changed and either updates existing fields or adds new information. The list_contacts() function takes the contact book as an input and lists all contacts in the console. Finally, the show_contact() function takes the contact book and a name as input and then displays all stored data in a formatted manner.",127,115,{},1,"KC,KH","functions,lists,dictionaries,(args/kwargs) arguments","input/output handling,conditionals,loops",
7,"Explain following programming task: ""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""",3,"This programming task involves writing a Python module that contains functions for managing a contact book. This contact book is stored as a list of dictionaries, where each dictionary contains the contact data. The functions to be implemented are: add_contact(), del_contact(), edit_contact(), list_contacts(), and show_contact(). The add_contact() function takes the contact book and a name as input, and adds a new entry to the list with the given name plus additional fields. The del_contact() function takes the contact book and a name as input, and deletes the contact with the given name from the book. The edit_contact() function takes the contact book, a name, and the fields to be updated as input, and edits the contact with the specified name and values. The list_contacts() function takes the contact book as input, and prints out the names of all contacts in the book. Finally, the show_contact() function takes the contact book and a name as input, and prints out all the stored information for that person.",165,143,{},1,"KC,KH","functions,lists,dictionaries,(args/kwargs) arguments","input/output handling,conditionals,loops",
8,"Explain following programming task: ""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""",1,"A) Iterative version of the function differences(values):
	
	def differences(values):
    	result = []
    	i = 0
    	while i < len(values) - 1:
        	result.append(values[i+1] - values[i])
        	i += 1
    	return result

B) Recursive version of the function palindrome(word):

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] == word[-1]:
			return palindrome(word[1:-1])
		return False",59,53,{},"0: ""Code structure wrong. Functions not converted.""",Solution,"functions,loops,string manipulation,variables,conditionals,lists,iteration/recursion",,variables
8,"Explain following programming task: ""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""",2,"Answer:

a) Rewritten function - Iterative version:

	def differences(values):
		result = []
		i = 0
		while i < len(values) - 1:
			result.append(values[i+1] - values[i])
			i += 1
		return result

b) Rewritten function - Recursive version:

	def palindrome(word):
		if len(word) == 0 or len(word) == 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])",58,50,{},"0: ""Code structure wrong. Functions not converted.""",Solution,"functions,loops,string manipulation,variables,conditionals,lists,iteration/recursion",,variables
8,"Explain following programming task: ""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""",3,"A:
a) The function differences(values) is not a recursive function, so we will convert it into a recursive function:

def differences(values):
	if len(values) <= 1:
	   return []
	return [values[-1] - values[-2]] + differences(values[:-1])

b) The function palindrome(word) is a recursive function, so we will convert it into an iterative function:

def palindrome(word):
	for i in range(len(word) // 2):
		if word[i] != word[-i-1]:
			return False
	return True",74,66,{},1,Solution,"functions,string manipulation,conditionals,lists,iteration/recursion",loops,
9,"Explain following programming task: ""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""",1,"This programming task involves creating a function to generate a square matrix (n x n) of random integers in the range of 0 to 9, and a recursive function to find the most cost-effective path from the top-left corner to the bottom-right corner. For the path-finding function, costs of each field are based on the respective element value of the matrix. The function should compare the costs of the neighboring fields and keep from revisiting a field. Additionally, if the matrix is modified, the copy module can be used. The function should return both the minimum costs and the optimal path to the destination. It might also be useful to provide an optional parameter for the starting position. It is recommended to start by testing the function with small matrices, as the calculations can take a long time.",142,130,{},1,"KC,KH,KMC","functions,randomness,modules,lists,iteration/recursion","conditionals,loops",
9,"Explain following programming task: ""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""",2,"This programming task is asking the programmer to write two functions- one to create a random square matrix (n x n) with integers in the range of 0 to 9, and one to find the most cost-effective path from the top-left corner to the bottom-right corner based on the elements of the matrix. The cost of a path corresponds to the sum of the costs of all visited fields. There are several constraints on this task- each field can only be visited once, only the directly neighboring fields can be visited, and the matrix is represented by a two-dimensional nested list. The programmer may also need to use the copy module to avoid issues with the given matrix being modifiable. Finally, the programmer should test the function for small matrices first due to the complexity of the calculations.",142,120,{},1,"KC,KH,KTC","functions,lists,iteration/recursion,modules","conditionals,loops,randomness",
9,"Explain following programming task: ""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""",3,"a) This task requires the creation of a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function will then need to create a matrix (nested list) with random values from 0-9 and return it.

b) This task requires the implementation of a recursive function that receives the matrix parameter and calculates the optimal path, i.e., with the lowest costs, from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path. To find the optimal path, the function will need to compare the costs of neighboring fields. To avoid revisiting already visited fields, the visited locations can be marked in the matrix, for example, using math.inf or -1. Additionally, it may be useful to provide an additional optional parameter for the starting position. Finally, it is recommended to test the function initially with small matrices as calculations can take a very long time.",169,150,{},1,"KC,KH","functions,randomness,lists,iteration/recursion,documentation","conditionals,loops,modules",documentation
10,"Explain following programming task: ""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""",1,"Answer: 

The following Python code can be used to read a text from a given file and use regular expressions (re) to extract the requested elements and output them on the console. 

import re

#Open file
file = open('text_file.txt', 'r')

#Read from file
text = file.read()

#Find strings between < and the next >
strings = re.findall(r""<[^>]*>"", text)
print(strings)

#Find numbers between 1900 and 2099
years = re.findall(r""\b19[0-9][0-9]\b|\b20[0-9][0-9]\b"", text)
print(years)

#Close file
file.close()",89,68,{},1,Solution,"input/output handling,regex,file i/o", file i/o,"input/output handling,file i/o"
10,"Explain following programming task: ""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""",2,"This task requires the use of Python regular expressions (re) to extract specific data from text stored in a file. 

For part a, the task is to extract all character strings located between < and the next >. This requires using re to search for regular expressions of the form <*>. The asterisk indicates the regular expression will match any character string in between < and >, including the opening < and closing >, as specified.

For part b, the task is to extract all year numbers between 1900 and 2099. This requires using re to match all regular expressions of the format 19[0-9][0-9], which indicates any two-digit year between 1900 and 1999, and 20[0-9][0-9], which indicates any two-digit year between 2000 and 2099.

Thus, the code should use functions from the re module, such as re.findall, to search for the abovementioned regular expressions and output them on the console.",154,102,{},1,"KC,KH","file i/o,regex", file i/o,file i/o
10,"Explain following programming task: ""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""",3,"Solution:

# import the re module
import re

# open txt file for reading
with open('textfile.txt', 'r') as f:
    # read the text file
    text = f.read()

# a) Extract the character strings between < and the next >
# using the re module and regular expressions
# Documentation: https://docs.python.org/3/library/re.html
strings = re.findall(r'<[^>]*>', text)

# print the output
print(f'Character strings between < and the next >: {strings}')

# b) Extract the numerical values between 1900 and 2099
numbers = re.findall(r'[1-2][0-9]{3}', text)

# print the output
print(f'Year numbers between 1900 and 2099: {numbers}')",99,78,{},1,Solution,"input/output handling,file i/o,comments,regex,documentation", file i/o,"input/output handling,file i/o,comments,documentation"
11,"Explain following programming task: ""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""",1,"This programming task requires the creation of a game that follows the rules outlined in the task. The game is implemented using functions that create a list of cards, deal cards to the players, compare cards, and handle the game flow. The game can be played with 2-5 players and the number of rounds is calculated based on the total number of cards and number of players. At the end of each round, the cards are collected, shuffled, and the next player takes the starting position. The game can be won by either winning the most tricks (variants a) or most rounds (variant b).

A computer opponent should be programmed and a user interface should be created. The user interface should inform users about valid inputs, indicate whose turn it is, allow the user to quit or start a new round, and be robust against incorrect user inputs. Additionally, the game should be implemented by creating additional functions and structuring the code accordingly.",164,139,{},1,"KC,KH,KTC","functions,input/output handling,variables,conditionals,randomness,exception handling,lists,user interface design,dictionaries",loops,"functions,variables,randomness,user interface design"
11,"Explain following programming task: ""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""",2,"This programming task requires the creation of a game using a standard 52 card deck. The game can be played with 2-5 players. The number of rounds is calculated by the formula: Number of rounds = floor(Total number of cards / Number of players). The round proceeds as follows: each player is dealt cards corresponding to the round number; a random trump suit is chosen; each player plays a card in turn with the highest-ranking card winning the trick; at the end of the round, all cards are collected and shuffled, and a new round begins with the next player in the order as the starting player. The winner is chosen based on either the most tricks won or the most rounds won.

In order to complete this programming task, the following functions must be implemented: create_cards(), which returns a list of cards; deal_cards(), which simulates dealing the cards to the players; compare_cards(), which handles card comparisons; and a game flow program that utilizes the newly created functions. Additionally, a computer opponent should be created that can perform actions for players defined as computer opponents. Finally, a simple console-based user interface must be built that allows the users to control the program, end the game, or start a new round. The user interface should be designed to be robust, ensuring that any incorrect user inputs do not lead to a crash.",233,208,{},1,"KC,KH,KTC,KMC","functions,input/output handling,conditionals,randomness,exception handling,lists,user interface design,dictionaries",loops,"functions,randomness,user interface design"
11,"Explain following programming task: ""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""",3,"This programming task requires the implementation of a game with the given rules. The game should use a standard deck of 52 cards. It can be played with two to five players. To determine the number of rounds, the formula Total number of cards / Number of players is used.

At the beginning of a round, each player is dealt a number of cards that corresponds to the round number. After that, a trump suit is chosen randomly. Each round is played for tricks, and each player plays a card in turn. The highest-ranking card wins the trick. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player. The winner is determined based on either the most tricks won or the most rounds won.

The programming task also requires the implementation of some basic functions that include creating a list of cards, dealing the cards to the players, and handling card comparisons. Additionally, a computer opponent must be implemented that can perform actions for players that are defined as computer opponents. Finally, a simple console-based user interface must be developed that can be controlled by keyboard input and guides the user through the program. The user interface should be robust and should inform the user about valid inputs and their effects.",229,206,{},1,"KH,KTC,KMC","functions,randomness,exception handling,lists,user interface design,dictionaries","input/output handling,loops,conditionals","functions,randomness,user interface design"
12,"Explain following programming task: ""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""",1,"This programming task requires the implementation of an object-oriented ecosystem using basic rules about the interactions between plants and organisms living in an environment known as the habitat. The habitat will have to be initialized with size and other properties, and rules should be implemented regarding the growth, reproduction, propagation, and death of organisms as well as regarding the characteristics of plants. In addition to basic rules, five additional rules should be implemented which modify or expand upon existing rules, and at least two aspects should depend on randomness (e.g. the success of a hunt or the strength of plant growth). A console-based user interface should allow for initial user settings and provide the option to pause the ecosystem or simulate multiple rounds. It should also provide a clear representation of the state of the ecosystem after each round. Finally, inputs should be clear and robust, so they should not cause the program to crash.",158,138,{},1,"KC,KH,KTC","input/output handling,OOP,randomness,exception handling,user interface design","class inheritance,method overriding",
12,"Explain following programming task: ""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""",2,"This programming task requires you to build an object-oriented simualtion of an ecosystem. There are different types of organisms (herbivores, omnivores, and carnivores) as well as different types of plants. In each round, organisms grow, reproduce, and propagate and may die from disease, injury, lack of food, being eaten, or old age. Plants also regenerate at a certain rate and require a certain amount of space to grow to their full potential. For the user interface, you should create some way for the user to set initial conditions and some way to represent the state of the ecosystem after each round. 
You should also include some random elements and define at least five additional rules (e.g. what if the habitat is full and no more plants can grow?). Finally, you should make sure all user input is clear and robust and that the program should not crash due to incorrect input.",153,140,{},1,"KC,KH,KTC","randomness,user interface design,OOP,exception handling","class inheritance,method overriding,input/output handling",
12,"Explain following programming task: ""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""",3,"This programming task requires the implementation of an ecosystem system with object-oriented programming. The starting point is creating a habitat with initial settings, such as size and other properties. The habitat is home to various organisms such as herbivores, omnivores, carnivores, and plants. The simulated environment works in rounds, where organisms can grow, reproduce, and propagate. All organisms have to continually eat to avoid starvation. Plants regenerate to a certain extent each round, depending on the plant species.

Additional rules should be implemented to expand or modify the initial rules, such as what happens if growing plants are eaten or the habitat is full and no new plants can grow. Randomness should be incorporated in certain aspects, such as the success of a hunt.

A console-user interface should be created, prompting the user for initial settings. After the activation of the ecosystem, no further user intervention is necessary. The user should be able to pause the ecosystem or activate multiple rounds. The state of the ecosystem should be clearly represented after each round. User inputs should be clear and robust, not crashing if incorrect input is entered.",189,171,{},1,"KH,KTC","method overriding,randomness,OOP,user interface design","class inheritance,exception handling,input/output handling",
0,"Identify the required programming concepts for following task: ""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""
For each concept give a general explanation with an example.",1,"1. Variables: Variables are used to store data and are further referenced in a program. For example, in the given task, you can create variables like ‘bank_code’, ‘account_number’, ‘IBAN’, ‘country_code’, etc.

2. Data types: Different data types help to store different types of data within a program. For instance, in the given task, one can use strings to store information like bank_code or account number and numerical data type for storing values like checksum.

3. Control flow: Control flow refers to the sequence in which program instructions are executed. For the given task, the program should collect input from the user, calculate and float the checksum and output the resultant IBAN while prompting for more details, if necessary. 

4. Loops: Loops enable a program to iterate through a sequence of instructions until a certain condition is met. In the given task, the program should perform specific steps until the user inputs a valid bank code and account number.

5. Functions: Functions enable a program to split complex tasks into manageable units, thereby making them easier to reference and debug. In the given task, one can use functions like ‘promptForInput()’ - that collects inputs from the user, ‘calculateChecksum()’ and ‘outputIban()’ that displays the IBAN with the checksum. 

6. Error handling: Error handling is used to anticipate and respond to errors that may arise during program execution. For the given task, it is essential to use error handling to anticipate and rectify any errors that may occur due to invalid inputs or broken algorithms.",251,119,"{‘0': 'Inputs are missing.’, ‘1’: ‘Output is missing.’}",1,"KC,KH","functions,variables,loops,exception handling","input/output handling,string manipulation,comments,documentation","functions,loops,exception handling"
0,"Identify the required programming concepts for following task: ""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""
For each concept give a general explanation with an example.",2,"1. User Input: User input is a feature used in programming to allow a user to input information for the program to use. An example would be for a user to enter their name when the program requests it.

2. Input Verification/Validation: Input verification/validation is a process of checking that data entered into the program is complete and correct. An example would be validating that an email address entered into the program is in the required email format.

3. Output Messages: Output messages are messages that communicate the results of a program to the user. An example would be a message that says “Your account has been created” after a user signs up.

4. Error Checking/Handling: Error checking/handling is a feature used to verify the user input values before they are used for processing. An example would be having the program check that the bank code (Bankleitzahl) is valid before performing any other functions.

5. Comments: Comments are sections of code used to document the program and make the code easier to read and understand. An example would be adding a comment at the top of a function to explain what it does and what inputs it expects.

6. Documentation: Documentation is detailed information about how to use the program, including what inputs are required and how they should be provided. An example of documentation would be a user guide that explains how to use the program and all of its features.",246,139,{},1,"KC,KH","input/output handling,documentation,comments","variables,string manipulation",
0,"Identify the required programming concepts for following task: ""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""
For each concept give a general explanation with an example.",3,"1. Variables: Variables are named objects that can store data, that can be used and changed within a program. In this case, variables would be used to store the bank code, account number, and country code as input. 

2. Datatypes: Datatypes specify the type of data a particular variable is loading. In this program, the bank code would be an integer, the account number would be a string, and the country code would be a string. 

3. Control Flow Statements: Control flow statements are used to define how a program behaves in different scenarios. For example, the program might use an if statement to either prompt for the country code or to hardcode it, depending on what the user desires.

4. Loops: Loops are programming structures that allow repeated execution of a block of code. In this program, loops could be used to keep asking for user input until all three pieces of information have been provided. 

5. Functions: Functions are blocks of code that are wrapped up in a name, allowing them to be used repeatedly. This program might include a function to process the banking information and output the complete IBAN number. 

6. Documentation: Documentation is extra comment lines that explain the various sections/blocks of code. This can improve the structure and readability of the code, as required for this problem. 

7. Error Handling: Error handling is the process of anticipating, recognizing, and addressing errors when they occur. This code should contain mechanisms to handle invalid entries and prevent them from crashing the program.",257,131,"{‘0': 'Inputs are missing.’, ‘1’: ‘Output is missing.’}",1,"KC,KH,KMC","functions,loops,variables,conditionals,exception handling,documentation","input/output handling,string manipulation,comments","functions,loops,conditionals,exception handling"
1,"Identify the required programming concepts for following task: ""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""
For each concept give a general explanation with an example.",1,"1. Input/Output: Input/Output involves reading data from the user/an external source and generating output. For example, when a program reads a number from the user through the console and prints its square, this is an example of Input/Output. 

2. Control Flow: Control Flow is the sequence in which instructions are executed. In this task, the program must check if the year inputted is a leap year, and only if it is a leap year will the corresponding message be displayed. This requires the program to make decisions based on conditions, control which instructions are to be executed, and track the program's progress and current state.

3. Variables and Data Types: Variables are used to store user input and the result of mathematical calculations, and allow data to be manipulated. The type of variable used in this task would be integer, as years are usually expressed as whole numbers.

4. Conditions (if statements): Conditions allow the computer to make decisions based on certain conditions being met. In this task, the program needs to use 'if statements' to quickly identify if the inputted year is a leap year or not.",193,85,{},1,"KC,KH","variables,input/output handling,conditionals",string manipulation,
1,"Identify the required programming concepts for following task: ""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""
For each concept give a general explanation with an example.",2,"1. Data Types: Data types are used to store data, especially when programming. Examples of data types are numbers, strings, booleans, floats, etc. In this task, the program will need to recognize and work with a numerical data type, since it is dealing with year values.

2. Variables: Variables are important in programming languages, as they store values to be used in the program. In this task, the program will need to create and use a variable to store the year value read from the console. 

3. Control Flow: Control flow is the order of execution of the statements of the program. In this task, the program will first read the year value from the console, then check whether it is a leap year or not, and then display the result accordingly. 

4. Input/Output: Input/output is used for getting data into a program (input) and sending data from a program (output). In this task, the program will need to take the year value from the user (input) and also display the result to the console (output). 

5. Logical Operators: Logical operators such as ""and,"" ""or,"" and ""not"" are used to compare values and make decisions. In this task, the program will need to use logical operators to compare a year to the given rules for check if it is a leap year. 

6. Conditional Statements: Conditional statements are used to execute code if certain conditions are met. In this task, the program will need to use a conditional statement to determine if a given year is a leap year or not.",263,127,{},1,"KC,KH","variables,input/output handling,conditionals",string manipulation,
1,"Identify the required programming concepts for following task: ""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""
For each concept give a general explanation with an example.",3,"1. Conditional statement: A conditional statement is a programming construct used to decide whether a certain piece of code should be run or not. For example, in the above task a conditional statement could be used to determine if a certain year is a leap year or not. 

2. Input/Output (I/O): I/O is the exchange of data between the user and the computer program. In the above task, you would need to use user input (the year) to determine if it is a leap year and use output (the complete sentence) to display the result to the user. 

3. Data Type: Data types are used to define the type of data that will be stored in a variable. For this task you need to use variables to store values (year) and since those variables would contain numerical data, you would need to use a numerical data type such as int. 

4. Loops: A loop is used for repeated execution of a certain set of instructions. For this task, you could use a loop to continuously ask the user to input a year, and perform calculations to determine if the year is a leap year or not. 

5. String Manipulation: String manipulation is used to manipulate strings in code. For this task, you would need to use string manipulation to construct the complete sentence by combining strings and the output of the calculations.",235,111,{},1,"KC,KH","loops,input/output handling,string manipulation,variables,conditionals",,loops
2,"Identify the required programming concepts for following task: ""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""
For each concept give a general explanation with an example.",1,"1. Variables: Variables are used to store information for later use. For example, in this task, one variable could be used to store the Boolean value of whether a leap year has been entered. 

2. Conditional Statements: Conditional statements are expressions that evaluate to either true or false. In this task, you can use conditional statements to check which inputs the user has entered to determine the number of ""Friday the 13th"" occurrences. 

3. Loops: Loops are used to repeat a set of instructions until a certain condition is met. For example, you could use a loop to cycle through all of the days in a year to determine when ""Friday the 13th"" will occur. 

4. Match-Case (Python 3.10): The match-case feature in Python 3.10 is a type of switch statement with a syntax that allows you to test for multiple conditions in a single expression. For example, you could use match-case to check the input entered by the user and determine the number of ""Friday the 13th"" occurrences accordingly.",175,94,"{‘0': 'Inputs are missing.’, ‘1’: ‘Output is missing.’}",1,"KC,KH","variables,loops,conditionals","input/output handling,string manipulation",
2,"Identify the required programming concepts for following task: ""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""
For each concept give a general explanation with an example.",2,"1. Input Validation: Input validation is used to ensure that the data a user enters into a program is what the program is expecting. For this task, input validation could be used to check whether the user has correctly inputted a value for leap year or non-leap year and to ensure the data entered is valid. An example of input validation could be writing a statement that a year must be inputted in order for the user to calculate the minimum and maximum number of ""Friday the 13th"" occurrences. 

2. Modularization: Modularization is a technique to break a program down into smaller, easier to understand blocks of code that can be reused whenever necessary. For this task, modularization could be used to separate the code that checks whether it is a leap year or not from the code that calculates the minimum and maximum number of ""Friday the 13th"" occurrences. This would make it easier to maintain and debug the program as multiple functions can be called and tested without interfering with each other. An example of modularization in this task could be writing a separate function to calculate the minimum and maximum number of ""Friday the 13th"" occurrences depending on whether it is a leap year or not and another function to display the output. 

3. Control Flow Statements: Control Flow Statements are used to determine the order in which instructions are executed in a program. For this task, control flow statements could be used to determine the path the program goes down based on the user’s input. An example of control flow statement in this task could be writing an if statement to check whether the user’s input for a leap year or non-leap year is true, then executing a set of instructions accordingly.",300,184,{‘1’: ‘Output is missing.’},1,"KC,KTC","functions,input/output handling,conditionals","variables,string manipulation,loops",functions
2,"Identify the required programming concepts for following task: ""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""
For each concept give a general explanation with an example.",3,"1. Variables: Variables are like containers for data, such as numbers, text strings, and so on. A variable can be created in a program to store a value. For example, in this program you could create a variable called “user_input” to store the input from the user regarding a leap year or not.

2. Loops: A loop is used to execute code multiple times. In this program, a loop could be used to check each day of the year and determine if it’s a Friday the 13th. 

3. Conditional statements: Conditional statements are used to execute a line of code based on a certain condition. In this program, conditional statements could be used to decide when to calculate a Friday the 13th, depending on the input from the user. 

4. Match-case statement: A match-case statement is a new feature in Python 3.10. It can be used to evaluate an expression and match it to one of a limited set of alternatives, and then execute a line of code associated with that alternative. In this program, match-case could be used to compare the user input with the choices for leap year or non-leap year, and then execute the relevant code. 

5. Functions: Functions are code blocks that perform a single task. In this program, a function could be created for calculating the minimum and maximum number of Friday the 13th occurrences in a year. This could make the code easier to read and reuse. 

6. Output: Output is what the user sees when the program is run, such as text or numbers. In this program, the output should be clear and understandable for the user. Output could be displayed as text or as a graph.",290,159,{},1,"KC,KH,KTC","functions,loops,input/output handling,variables,conditionals",string manipulation,functions
3,"Identify the required programming concepts for following task: ""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""
For each concept give a general explanation with an example.",1,"a) Functions: A function is a set of statements that take inputs, processes them, and produces outputs. For example, in the given task, the function “chessboard” takes no inputs, processes information to display each square with its corresponding label, and produces an output of a chessboard displayed in the console. 

b) Parameters: Parameters are values or variables passed into a function. In the given task, the function “queen_on_chessboard” takes the position of a queen as its parameter and displays the queen at the corresponding square on the chessboard. If no parameter is passed, the same behavior as in the function in subtask a is exhibited.",105,83,{},1,"KC,KH","functions,parameters","input/output handling,string manipulation,conditionals,loops",parameters
3,"Identify the required programming concepts for following task: ""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""
For each concept give a general explanation with an example.",2,"1. Function: A function is a subroutine written in code that can be called multiple times with different inputs to produce an output. For example, a function could take two numbers as input and output their sum.

2. Parameters: Parameters are variables used as inputs when a function is called. For example, in the ""queen_on_chessboard"" function, the position of the queen would be a parameter.

3. Strings: A string is a series of characters, such as letters, numbers, and symbols, stored in memory. For example, ""B4"" is a string that the ""queen_on_chessboard"" function could use.

4. Symbol: A symbol is a special character used for representing something else. For example, the ""queen_on_chessboard"" function could use the ♛ symbol to represent the queen on the chessboard.",124,80,{},1,KC,"functions,variables,string manipulation","input/output handling,conditionals,loops",variables
3,"Identify the required programming concepts for following task: ""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""
For each concept give a general explanation with an example.",3,"a) Function: A function is a block of code that performs a specific task, such as generating a chessboard. For example, the ""chessboard"" function mentioned in the task could be written like this:

def chessboard():
    for row in range (1,9):
        for column in range (1,9):
            print(""{}{}"".format(row,column), end="" "")
        print()

b) Parameters: Parameters are values that are passed into a function, allowing it to perform operations on the data provided. In the example task, the ""queen_on_chessboard"" function takes in the position of a queen as input. For example, the function call could look like this: queen_on_chessboard(B4).",100,69,{},0: 'The code snippet incorrectly combines two numbers.',"KC,KH","functions,loops,input/output handling,string manipulation",conditionals,
4,"Identify the required programming concepts for following task: ""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""
For each concept give a general explanation with an example.",1,"1. Iteration: This is the repetitive execution of a set of instructions or tasks. It is often used to traverse structures such as arrays and objects in order to apply the same instructions or tasks to each element in the structure. An example would be a loop that traverses an array of integers, adding 1 to each element.

2. Algorithm Design: This is the process of developing instructions to solve a problem, as well as verifying and analyzing the solution to determine whether it is optimal or not. An example of an algorithm design would be designing a solution to generate the Fibonacci sequence.

3. Variables: This is a storage location that stores a value which can be changed during program execution. An example of a variable declaration would be declaring an integer to store the number of matchsticks remaining.

4. Function: This is a self-contained block of code which takes some input, performs a computation, and returns some output. An example of a function would be one which takes the number of matchsticks remaining and creates an output representing the matchsticks visually.",184,90,{},1,"KC,KH","functions,variables,iteration/recursion","input/output handling,string manipulation,conditionals,loops","variables,iteration/recursion"
4,"Identify the required programming concepts for following task: ""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""
For each concept give a general explanation with an example.",2,"1. Iteration: Iteration is a programming concept which uses a loop to iterate over a set of data repeatedly, performing the same set of operations at each step. An example of this in Python is a for loop which runs until a condition is met (e.g. the number of matchsticks has reached 0).

2. Variables: Variables are used to store data which is used in programming. Variables can be used to store data such as the current number of matchsticks or the current player. An example of variable usage in Python is int num_matchsticks = 13.

3. Conditional Statements: Conditional statements are used to evaluate expressions and execute certain code based on the result of the expression. An example of using a conditional statement in Python is if num_matchsticks >= 0: print('Player 1 wins!').

4. User Input: User input is used to accept data from a user. In Python, this is typically done with the input() function which stores the user input as a string. An example of using user input for this program is taking user input from the players to determine how many matchsticks they want to remove.

5. Functions: Functions are used to organize code and make it more reusable. An example of creating a function for this program is to create a visualizing function which takes the remaining matchsticks as a parameter and displays them in the console.",232,123,{},"0: ""Wrong variable declaration.""","KC,KH","functions,input/output handling,variables,conditionals,iteration/recursion","string manipulation,loops","variables,iteration/recursion"
4,"Identify the required programming concepts for following task: ""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""
For each concept give a general explanation with an example.",3,"1. Variables: Variables are used to store data or values and can be used throughout the program. In this example, a variable can be used to store the number of remaining matchsticks. 
2. User Input: User input is necessary so the players can choose how many matchsticks to remove. In the program, it might be accomplished with an input function. 
3. Loops: Loops are used to repeat certain steps over and over again, such as prompting the player to choose a number of matchsticks to remove. A while loop can be used here to keep track of the number of matchsticks and repeat the prompting until one of the players has won. 
4. Functions: Functions are used to logically group related lines of code so that they can easily be reused and organized. In this example, a separate function can be used to visualize the matchsticks. The function could take the parameter of the number of remaining matchsticks and then display the output accordingly.",164,90,{},1,"KC,KH","functions,variables,input/output handling,loops","string manipulation,conditionals",variables
5,"Identify the required programming concepts for following task: ""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""
For each concept give a general explanation with an example.",1,"1. Module/Package Import: Refers to the process of loading modules/packages into a program for use. For example, the “import random” statement imports the built-in random module so that calls to “random.randint()” can be used.

2. File Input/Output: Refers to the process of reading and writing data from/to files. For example, the “open()” function opens a specified file for reading or writing and returns a file object that can be used to manipulate the data within the file.

3. String/Character Processing: Refers to the manipulation of strings and characters. For example, the “+” operator can be used to concatenate two strings together.

4. Control Structures: Refers to the use of control statements (blocks of code) that determine the flow of a program. For example, the “if” statement allows for the selection of one or more paths of execution based on a boolean condition.

5. Data Structures: Refers to the use of data structures (arrays, dictionaries, etc.) to provide efficient ways of accessing and manipulating data. For example, arrays can be used to store and recall large quantities of data quickly.",185,116,"{‘0': 'Inputs are missing.’, ‘1’: ‘Output is missing.’}",1,"KC,KH","functions,file i/o,string manipulation,conditionals,modules","input/output handling,loops,randomness",file i/o
5,"Identify the required programming concepts for following task: ""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""
For each concept give a general explanation with an example.",2,"1. Modules: Modules provide helpful functions that can be imported and used without further installation. An example is the standard installation of Python 3.X which includes a wide range of modules that already come with Python.

2. Functions: Functions are used to perform specific tasks and they are written to take in parameters and return a desired result. For example, we can create a function called  “decimal_to_binary” that takes a positive integer as an argument and returns a string representing its binary representation.

3.Loops: Loops are used to repeatedly execute code until either a certain condition is satisfied or a predetermined number of iterations is reached. For instance, if we are using the “exam_countdown” function, we can use a loop to calculate the time between a given timestamp and the first EPI exam on February 16, 2023.

4. Conditional Statements: Conditional statements are used to implement logic that includes different paths based on certain conditions. For example, in the “open_course_page” function, we could use a conditional statement to check if the provided module abbreviation is a valid one. If it is, the function should return True, otherwise it should return False.

5. Variables: Variables are used to store data. They come in different types, such as integers, booleans, strings, etc. An example of a variable can be the length of a password when using the “password_gen” function.

6. User Input: User input is used to prompt the user for information in a given program. This can be done using the Python functions “input()” and “raw_input()”. For example, when writing a Python program that imports the module “eprtools.py” created in Task 1, the user can be prompted for input to choose which of the four implemented tools should be executed.",292,218,"{1: ""Does not address the difference between 'return' and 'display'.""}",1,"KC,KH","functions,loops,variables,conditionals,input/output handling,modules","string manipulation,randomness",variables
5,"Identify the required programming concepts for following task: ""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""
For each concept give a general explanation with an example.",3,"1. Modules: Modules are pre-written functions or classes that provide advanced features to a Python program. For example, the ""time"" module provides functions for working with time and calendar data, such as calculating time differences and retrieving the current Unix timestamp. 

2. Built-in Modules: Built-in modules are modules that come standard with the Python installation and are available without further installation. An example of a built-in module is the ""random"" module, which is used for generating pseudo-random numbers.

3. Importing Modules: In order to use a module, it needs to be imported first. This can be done by using the ""import"" statement. For example, in order to use the ""time"" module, the following line must be added at the beginning of the program: ""import time"".

4. Function: Functions are named blocks of code that are used to perform a certain task. In the given example, functions are used to implement the different tools. A function example is the ""decimal_to_binary"" function, which takes a positive integer as an argument and returns a string representing its binary representation.

5. Parameters: Parameters are the variables that are passed into a function via the function call. An example would be the ""length"" parameter of the ""password_gen"" function, which determines the length of the generated password.",216,160,"{1: ""Does not address the difference between 'return' and 'display'.""}",1,"KC,KH","functions,documentation,modules,time","input/output handling,string manipulation,conditionals,loops,randomness","documentation,time"
6,"Identify the required programming concepts for following task: ""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""
For each concept give a general explanation with an example.",1,"1. Variables – a named memory location that stores value, for example CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"", ""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""] in the given task is a variable.

2. Modules – a piece of code which defines various data elements and procedures that can be accessed by other pieces of codes, for example ""memory.py"" in the given task.

3. Nested Lists – a list in which each element is another list, for example creating a 5x4 game grid in the given task is a nested list.

4. Functions – a piece of code which is able to perform an operation and return a result, for example create_grid(cards) and get_symbols(grid, pos1, pos2) in the given task.

5. Tuples – an immutable data type which is a collection of values in a specific order and is indicated by parentheses, for example returning the symbols of two cards from get_symbols(grid, pos1, pos2) function in the given task is a tuple.

6. Loops – a block of code which is used to perform repetitive operations until a certain condition is met, for example until all pairs are found in the given task.

7. Exceptions – errors which are encountered and need to be handled in a program, for example incorrect user inputs are exceptions.

8. Input/Output – functions which allow a program to take input from the user and print output to the user, for example taking two cards from the player and displaying the game board are input/output functions.",236,168,{},1,"KC,KH","functions,loops,input/output handling,variables,modules,exception handling,lists","string manipulation,conditionals,randomness,time",variables
6,"Identify the required programming concepts for following task: ""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""
For each concept give a general explanation with an example.",2,"1. Modular Programming: This programming concept involves breaking down code into self-contained sections (modules) which can be easily managed and reused. Examples: creating functions, classes, modules, etc.

2. Nested Data Structures: This programming concept involves organizing data into a hierarchical structure. Examples: creating nested lists, dictionaries, etc.

3. Conditional Statements: This programming concept involves writing code that can make decisions by comparing values, testing conditions, and executing different blocks of code. Examples: using if-else statements, switch statements, etc.

4. Iteration: This programming concept involves repeating a set of instructions multiple times until a certain condition is met. Examples: using for-loops, while-loops, recursive functions, etc.",108,34,{},1,"KC,KH","functions,conditionals,modules,lists,iteration/recursion","input/output handling,string manipulation,loops,randomness,exception handling,time",iteration/recursion
6,"Identify the required programming concepts for following task: ""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""
For each concept give a general explanation with an example.",3,"1. Functions - A function is a block of Python code that can be run to complete a particular task or sequence of tasks within a program. For example, the create_grid() function in the question would take a cards list and return a 5x4 grid of the cards.

2. Nested lists - A nested list is a type of data structure in Python where a list can contain items which are themselves lists. For example, the create_grid() function would create a grid of the 20 cards that consists of nested lists.

3. Arguments - Arguments in a function are pieces of data that are passed to the function that will be used as input in some way. The get_symbols() function, for example, takes the current game grid and the two card positions as input parameters.

4. Tuples - A tuple is an immutable sequence type in Python, similar to a list but with less features and functionality. The get_symbols() function would return the motifs of the two cards in the form of a tuple.

5. Loops - A loop is a control structure used to repeat a block of code a certain number of times. In the question, a loop would be used in the game logic to repeat steps (a)-(d) until all pairs are found.

6. Variables - Variables are used to store data or references to data that can be used in a program. In the question, the CARDS variable holds the 20 cards used in the game.

7. If/Else Statements - An if/else statement is a control structure used to execute a certain block of code if a condition is true, and another block of code if it is false. In the game logic, for example, if/else statements would be used to check if a pair is found and then decide whether to remove the cards from the game grid or not.",312,213,{},1,"KC,KH","functions,loops,variables,conditionals,(args/kwargs) arguments,lists","input/output handling,string manipulation,randomness,modules,exception handling,time","variables,(args/kwargs) arguments"
7,"Identify the required programming concepts for following task: ""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""
For each concept give a general explanation with an example.",1,"1. Data Structures: Data structures are used to store and organize data in a certain way so that it can be used efficiently. In this case, dictionaries and lists are used to store the contacts and create a contact book. For example, a contact can be represented as a dictionary with name as the key and other details such as email, address, date of birth as the value. 

2. Functions: Functions are used to encapsulate code written in a program to perform a specific task. In this example, functions are declared for the operations offered in the contact book such as add_contact(), del_contact(), edit_contact(), list_contacts() and show_contact().

3. Parameters: Parameters are variables passed to a function when it is called. For example, the add_contact(…) function takes the contact book as input, along with a name and other fields to be added to the contact as parameters.

4. Console Output: Console output is used to display information when a program runs. For example, the list_contacts(…) function takes the contact book as input and prints out the names of all contacts in the console.",182,126,{},1,"KC,KH","functions,lists,dictionaries,(args/kwargs) arguments","input/output handling,conditionals,loops",
7,"Identify the required programming concepts for following task: ""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""
For each concept give a general explanation with an example.",2,"1) Data Structures: Data structures are used to store and organize data. For the task described, a list and a dictionary would be used. The list is used to store the contact book, which consists of a collection of dictionaries. The dictionaries represent contacts and store them with fields (i.e. name, email, address, etc.). For example, a contact book may look like this: [{""name"": ""John Smith"", ""email"": ""johnsmith@example.com"", ""address"": ""Main Street 2""}, {""name"": ""Jane Doe"", ""email"": ""janedoe@example.com"", ""date of birth"": ""01/01/2000""}]. 

2) Functions: Functions are reusable pieces of code that can be used to accomplish specific tasks. In the example task, the functions add_contact(), del_contact(), edit_contact(), list_contacts(), and show_contact() are required. Each function takes the contact list and any additional parameters needed to modify the contact book or provide information. For example, the add_contact function takes a name and any additional parameters (e.g. email, address, birth date, etc.) that should be added to the contact book.

3) Parameters: Parameters are variables that are used for specifying the input that a function takes as arguments. In the example task, function add_contact() takes two parameters; the name and any additional information to be added to the contact book. The del_contact() function takes the contact book and the name of the contact to be deleted from the book. Similarly, the edit_contact takes the contact book, the name of the contact and the field(s) to be edited as parameters.",244,181,{},1,"KC,KH","functions,lists,dictionaries,(args/kwargs) arguments","input/output handling,conditionals,loops",
7,"Identify the required programming concepts for following task: ""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""
For each concept give a general explanation with an example.",3,"1. Lists: Lists are a type of data structure used in programming to store and manipulate data. An example of a list is a contact book, which stores all of a contact's information in one list.

2. Dictionaries: Dictionaries are a type of data structure used in programming to store and access information. They are composed of ""entries"", each containing a ""key-value pair"", where the keys are used to access the values. Dictionaries can be used to represent contacts in a contact book, with each contact having its own key-value pairs for name, address, email, etc. 

3. Parameters: Parameters are variables that are used within functions. For example, for the add_contact() function, parameters such as a name and additional contact details can be passed to the function.

4. Modules: Modules are collections of related functions, classes, and variables used for a particular purpose. In this task, a module is used to group together all the functions related to the contact book, such as add_contact(), edit_contact(), etc.

5. Formatting: Formatting is the process of presenting data in a particular way. In this task, formatting is used to properly display the contents of a contact in the show_contact() function.",200,122,{1: 'Does not explicitly mention the return value or the effect on the contact book.'},1,"KC,KH","functions,input/output handling,(args/kwargs) arguments,modules,lists,dictionaries","conditionals,loops",modules
8,"Identify the required programming concepts for following task: ""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""
For each concept give a general explanation with an example.",1,"1. Recursion: Recursion is a technique of writing a program or a part of a program that calls itself repeatedly. An example would be a function that calculates the factorial of a number (n!) - the function would call itself to multiply the current value by the previous lesser value until it reaches the base case (generally n = 1).

2. Iteration: Iteration is a technique of writing a program or a part of a program that repeatedly cycles back to the beginning and executes the same set of code until a certain condition is met. An example would be a loop that prints out the numbers from 0 to 9 - the loop would continue until its current value reaches the number 10 and then it will terminate.

3. List: A list is a data structure that stores values in a specified order. An example of a list would be a shopping list with items and their respective quantities.

4. Parameters: Parameters are variables passed into a function that are then used to execute code. In the example in the task and the example of the factorial function, the parameters were the values of the list for the differences function, and the word for the palindrome function.

5. Operators: Operators are characters that are used to compute values or perform a comparison. In the example of the differences function, the '+' and '-' operators were used to calculate values. In the example of the palindrome function, the '!=' operator was used to compare the values of the word's front and back positions.",258,144,{},1,"KC,KH","functions,operators,parameters,lists,iteration/recursion","string manipulation,conditionals,loops","operators,parameters"
8,"Identify the required programming concepts for following task: ""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""
For each concept give a general explanation with an example.",2,"1. Recursive Function: A recursive function is a function that calls itself. An example of a recursive function is one that calculates the factorial of a number (n!) where n! = n * (n-1)!.

2. Iterative Function: An iterative function is a function that performs a sequence of instructions over and over again until a certain condition is satisfied. An example of an iterative function is one that calculates the Fibonacci sequence where a term in the sequence is the sum of the two preceding terms. 

3. Function Parameters: Function parameters are values passed into the function when it is called. An example of a function parameter is the list of numbers passed into the differences() function in the provided task.

4. For Loop: A for loop is a type of loop structure that loops over a given sequence. An example of a for loop is one used within the differences() function to loop over all of the values within the list of numbers. 

5. List Append: List append is an action that adds an element to the end of a list. An example of a list append is one used within the differences() function to add the difference of two sequential values from the list to the resulting list.

6. String Slicing: String slicing is the process of accessing parts of a string by dividing it into segments. An example of string slicing is one used within the palindrome() function to access the characters of the provided word string outside of the first and last characters.",256,154,{},1,"KC,KH","functions,loops,string manipulation,lists,iteration/recursion",conditionals,
8,"Identify the required programming concepts for following task: ""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""
For each concept give a general explanation with an example.",3,"Recursion: Recursion is a programming concept in which a function can call itself directly or indirectly. This allows the program to repeat similar tasks multiple times. For example, the palindrome(word) function in the task is an example of using recursion.

Iteration: Iteration is a programming concept in which a loop is used to repeat a task multiple times. For example, the differences(values) function in the task uses a for loop to iterate through elements in the list, calculate the difference between two consecutive numbers, and then add the result to a list.",94,60,{},1,"KC,KH","functions,loops,iteration/recursion,conditionals","string manipulation,lists",
9,"Identify the required programming concepts for following task: ""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""
For each concept give a general explanation with an example.",1,"a) Creating the Matrix:
Creating a matrix is a common programming task involving various programming concepts, including loops and standard data structures. As an example, a basic multidimensional array can be used to represent a matrix of a given size. Here's an example of a loop to populate a 3x3 matrix:

matrix = [[0] * 3 for i in range(3)]
for i in range(3):
	for j in range(3):
		matrix[i][j] = random.choice(range(10))
		
b) Finding the Optimal Path: 
Finding the optimal path is a common problem in computer science, and to solve it, recursion is often a good choice. In this case, a recursive function can be used to calculate the minimum cost path from the start position to the end position. In addition to recursive functions, other concepts can also be used, such as loops, data structures, and comparisons. To mark visited fields, concepts like mutable variables and evidence-based return values may be used. For example, the following code uses a visited array to keep track of already visited fields:

def find_optimal_path(matrix, visited, start_x, start_y):
	# Base cases
	if start_x < 0 or start_y < 0 or start_x > len(matrix) - 1 or start_y > len(matrix) - 1:
		return 0

	# Mark the field as visited
	visited[start_x][start_y] = True

	# Compute the costs of each neighboring field
	cost_right = matrix[start_x][start_y + 1] if not visited[start_x][start_y + 1] else math.inf
	cost_down = matrix[start_x + 1][start_y] if not visited[start_x + 1][start_y] else math.inf
	cost_left = matrix[start_x][start_y - 1] if not visited[start_x][start_y - 1] else math.inf
	cost_up = matrix[start_x - 1][start_y] if not visited[start_x -1][start_y] else math.inf
	
	# Calculate the minimum cost
	min_cost = min(cost_right + find_optimal_path(matrix, visited, start_x, start_y + 1), cost_down + find_optimal_path(matrix, visited, start_x + 1, start_y), 
	cost_left + find_optimal_path(matrix, visited, start_x, start_y - 1), cost_up + find_optimal_path(matrix, visited, start_x - 1, start_y))
	
	# Mark the field as unvisited
	visited[start_x][start_y] = False
	
	# Return min cost
	return min_cost",322,200,"{1: 'The response does not explicitly return the path taken, only the minimum cost.', 2:  'The use of the copy module to handle the mutability of lists is missing.'}",0: “copy module missing.”,"KC,KH","functions,loops,variables,randomness,modules,lists,iteration/recursion",conditionals,variables
9,"Identify the required programming concepts for following task: ""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""
For each concept give a general explanation with an example.",2,"a) Creating the Matrix:	
This task requires knowledge of data structures such as lists, nested lists, and loops. Data structures are used to hold and organize data in meaningful ways. The example code below is a way to create a 3x3 matrix with random numbers in the range of 0 to 9. 

import random

def get_matrix(size):
    matrix = []
    for r in range(size):
        row = []
        for c in range(size):
            row.append(random.randint(0,9))
        matrix.append(row)
    return matrix
  
matrix = get_matrix(3)

b) Finding the Optimal Path:
For this task, knowledge of recursion is needed. Recursion is a programming concept where functions call themselves in order to solve problems. An example of a recursive solution for this task is shown below.

def get_cost(matrix, i, j, visited):
  if i < 0 or j < 0 or i >= len(matrix) or j >= len(matrix[i]):
    return float(""inf"")
  if visited[i][j]: #Avoid revisiting already visited fields
    return float(""inf"")
  if i == len(matrix)-1 and j == len(matrix[0])-1: #Base case for the recursion
    return matrix[i][j]
  visited[i][j] = True
  # Check neighboring fields
  cost_right = get_cost(matrix, i, j+1, visited)
  cost_down = get_cost(matrix, i+1, j, visited)
  cost_min = min(cost_right, cost_down)
  cost = cost_min + matrix[i][j]
  visited[i][j] = False
  return cost",214,133,{2:  'The use of the copy module to handle the mutability of lists is missing.'},0: “Horizontal/Vertical movement missing.”,"KC,KH,KTC","functions,loops,conditionals,randomness,modules,lists,iteration/recursion",,
9,"Identify the required programming concepts for following task: ""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""
For each concept give a general explanation with an example.",3,"1. Recursion: Recursion is a technique of solving a problem by breaking it down into a smaller instance of the same problem. For example, if we were trying to find the sum of the numbers in a list, we could use a recursive function to solve it. The recursive function would break the list down until it finds a list of one element, and then it will add the element to the sum of previous calls. 

2. Mutability: Mutability is an object quality that describes its ability to be changed or mutated. For example, lists are mutable objects meaning they can be modified in place. This can cause potential problems in our code if we are not careful. 

3. The copy Module: The copy module provides functions for creating an independent copy of an object, or parts of an object. For example, in the task above, we might make a copy of the matrix so that our modifications will not affect the original version. 

4. Nested Lists: A nested list is a list composed of other lists. For example, the matrix described in the task is a nested list, with each element of the list representing a row in the matrix. 

5. Algorithm: An algorithm is a sequence of steps that provide a solution to a particular problem. For example, to solve the task above, we would need to come up with an algorithm for finding the most cost-effective path. This algorithm could involve looping through the matrix, comparing neighboring costs, and calculating the lowest cost route.",258,167,{},1,"KC,KH","functions,mutation,modules,lists,iteration/recursion","conditionals,loops,randomness",mutation
10,"Identify the required programming concepts for following task: ""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""
For each concept give a general explanation with an example.",1,"a) Regular Expressions: Regular expressions, or regex, is a sequence of characters that define a search pattern that can be used to match and manipulate strings and sets of strings. An example would be using a regex pattern to search a text file for all instances of a specific set of characters and return the string of characters within the search pattern.

b) File Reading: File reading is the process of reading the contents of a file with a programming language. An example would be using a function to open a file, read its contents, and store its contents in a variable.",102,45,{},1,"KC,KH","file i/o,regex",,
10,"Identify the required programming concepts for following task: ""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""
For each concept give a general explanation with an example.",2,"a) Regular expressions (re) - A regular expression is a sequence of characters that are used to match patterns in strings. Regular expressions are used for text searching and text manipulation. An example of a regular expression in Python is ""\d+"", which is a wildcard for one or more digits.

b) File Input/Output (IO) - File input/output is the process of reading data from or writing data to a file. In Python, this is accomplished by using the open() function, which returns a file object. An example of file input/output in Python would be code to open a text file, read each line of the file, and then write each line of the file to another text file.",119,64,{},1,"KC,KH","file i/o,regex",,
10,"Identify the required programming concepts for following task: ""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""
For each concept give a general explanation with an example.",3,"a) Regular Expressions (Re): Regular expressions are a way of searching and manipulating strings using patterns. The re module in Python provides access to regular expressions.  For example, the expression '\d+' could be used to find sequences of one or more digits in a string. 

b) Input/Output: Input/Output (IO) is responsible for receiving information from the user (or program) and providing the output. For this task, the program must be able to read data from a given file and display the extracted elements on the screen or console. For example, the open() method could be used to open a file for reading and the print() method could be used to output the extracted elements.",116,69,{},1,"KC,KH","file i/o,regex",,
11,"Identify the required programming concepts for following task: ""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""
For each concept give a general explanation with an example.",1,"1. Variables: Variables store data and can be referenced by their identifier in the code. For example, in the given task, the total number of cards in the deck and the number of players could be stored in variables.

2. Data Structures: Data structures allow us to store data in different formats, like lists and dictionaries. In the given task, it would be beneficial to use lists to store the order of play and dictionaries to store the cards.

3. Control Flow: Control flow is used to construct logic and control the program execution sequence. For example, the game flow specified in the given task could be constructed using control flow. 

4. Loops: Loops are used to repeat certain operations multiple times until a certain condition is met. For example, in the given task, a single round could be based on a loop that iterates through all the players in order and distributes the necessary number of cards for that round. 

5. Functions: Functions are used to encapsulate code and provide a convenient way to execute the same sequence of instructions multiple times. For example, in the given task, there could be functions for creating the cards, dealing the cards, and comparing the cards that can be used whenever needed. 

6. Input/Output: Input/Output processes data coming in and out of a program. In the task, an example of this is when a user interacts with the console-based user interface to provide input and receive output from the program. 

7. Arithmetic Operators: Arithmetic operators are used to perform arithmetic operations with numbers. For example, in the given task, the formula for calculating the number of rounds would require arithmetic operators to perform the calculation. 

8. Algorithms: Algorithms are used to define logical sequences of operations. For example, in the task, an algorithm could be used to determine the outcome of the game.",314,195,{2: 'Additional requirements missing.’'},1,"KC,KH","functions,loops,input/output handling,control flow,variables,data structures","lists,dictionaries,conditionals,exception handling","functions,control flow,variables,data structures"
11,"Identify the required programming concepts for following task: ""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""
For each concept give a general explanation with an example.",2,"1. Data Structures: To implement this game, data structures such as lists and dictionaries will be used. For example, a list of characters ( Ace, 2,3,4 ... King) and a dictionary representing the suits of the cards will be used. 

2. Loops: Loops will be used to iterate through the data structures and implement each round of the game. For example, a for loop can be used to iterate through each card and assign each one to a player. 

3. Control Flow: Different control statements such as if-else and switch statements will be used to determine the results of comparisons between cards being played. For example, if-else statements can be used to compare the ranks and suits of two cards.

4. Algorithms: Algorithms will be used to implement the different steps in the game such as shuffling and dealing the cards, determining the starting player, and comparing the cards. For example, an algorithm can be written to compare the suits and ranks of two cards, and decide which one is the highest-ranking.

5. Functions: Functions will be used to group related code into reusable units. For example, a function can be created to shuffle and deal the cards, a function for determining the trump suit, and a function to compare the cards for each trick. 

6. Classes: Classes will be used to define the data structure of the cards and store their attributes. For example, a Card class can be created to store the rank and suit of each card, and a Deck class can be created to store a list of cards. 

7. Programming Paradigms: Object-oriented programming concepts such as inheritance, abstraction, and encapsulation will be used to design the program. For example, the properties and behavior of a card can be encapsulated in a Card class, and Card class can be inherited by a Deck class to customize its functionalities.",316,209,{2: 'Additional requirements missing.’'},1,"KC,KH","functions,loops,OOP,conditionals,class inheritance,dictionaries","input/output handling,lists,exception handling","functions,OOP,class inheritance"
11,"Identify the required programming concepts for following task: ""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""
For each concept give a general explanation with an example.",3,"1. Data Structures: Data structures are used to organize and structure data, making it easier to access, manage, and modify. Examples include arrays, dynamic arrays, linked lists, hash tables, stack, queue, binary trees, etc. An example of data structures in the given game is the use of a collection of dictionaries to represent cards.

2. Control Structures: Control structures are used to control the flow of a program, based on certain conditions. Examples include if-else statements, loops (while, do-while, for), switch-case statements, etc. An example of a control structure in the given game is the use of a loop to start a new round with a new set of cards each time.

3. Algorithms: Algorithms are well-defined sets of instructions for solving a problem. Examples include sorting algorithms (e.g., insertion sort, bubble sort, etc.), search algorithms (e.g., linear search, binary search, etc.), graph traversal algorithms (e.g., DFS, BFS, etc.), etc. An example of an algorithm in the given game is the comparison_cards() function, which finds the highest-ranking card among a collection of cards.

4. Functions: Functions are small, self-contained, reusable blocks of code that take in input parameters and return output values. An example of a function in the given game is the create_cards() function, which creates a collection of cards for the deck.

5. User Interaction: User interaction allows users to interact with and control the program using input controls, such as typing on the keyboard, clicking on buttons, etc. An example of user interaction in the given game is the user interface that guides the user through the program, allowing the user to end the game or start a new round.",282,162,{},1,"KC,KH","functions,loops,conditionals,user interface design,dictionaries","input/output handling,lists,exception handling","functions,user interface design"
12,"Identify the required programming concepts for following task: ""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""
For each concept give a general explanation with an example.",1,"Object-Oriented Programming (OOP): OOP is a programming paradigm that models concepts as objects that contain data (attributes) and methods to interact with them. An example of an object is a custom window class that contains data like width, height, and title, as well as methods to draw and close the window.

Inheritance: Inheritance is a mechanism in OOP that allows objects to inherit attributes and methods from a parent or superclass. This allows for code reuse while allowing objects to have a different behavior and characteristics. For example, you can create an Animal class and a Bird class, where the Bird class inherits from Animal.

Encapsulation: Encapsulation is a concept in OOP where attributes and methods can be defined and grouped in a single container (an object) and access to them is restricted. In our example, we can create an object that holds the attributes and methods of the habitat and only allow access to the ones that specify its size and population.

Polymorphism: Polymorphism is a concept in OOP where objects can have multiple forms and still share the same interface (by overriding methods). In our example, we can create different subclasses of plants that have different characteristics (minimum/maximum size, regeneration rate, etc.) and still retain the same interface (the same methods for growth, reproduction, etc.).

Randomness: Randomness is used to introduce elements of uncertainty that can be used to simulate real-world events. In our example, the success of hunts and the strength of plants growth can depend on a random element. This could be a number generated with the help of a random number generator.",270,172,{},1,"KC,KH","class inheritance,method overriding,randomness,OOP","user interface design,exception handling,input/output handling",
12,"Identify the required programming concepts for following task: ""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""
For each concept give a general explanation with an example.",2,"- Object-oriented programming: Object-oriented programming (OOP) is a programming paradigm based on organizing code into objects. OOP makes software development easier and more efficient by providing a way to structure programs so they are easier to maintain and extend. An example is a class in OOP called Animal which has methods such as Eat(), Sleep(), and Move().

- Abstractions: Abstractions are ways of creating a simplified version of a complex problem. It involves breaking the problem down into smaller parts, understanding the relationships between them, and representing the problem in a way that is easier to work with.For example, you can create an Animal class which abstracts the common characteristics of all types of animals such as feeding and reproduction.

- Encapsulation: Encapsulation is a software development technique used when organizing code into objects. It refers to grouping logically related code into classes or objects to form a structure that is easy to maintain and use. In OOP, this would involve hiding the implementation details of an object and only exposing a limited set of public methods or variables. An example would be creating a Bird class which encapsulates properties and methods related to flying behavior.

- Inheritance: Inheritance is another core concept of Object-oriented programming. It is a way of creating new classes from an existing parent class. This allows methods and properties that exist in the parent class to be inherited by the child class, which can be subclassed to specialize the behavior according to its own needs. For example, you could create a class called Eagle which inherits from the Bird class. It would then have all the same properties and methods as the Bird class, plus the ability to specialize the behavior related to eagles.

- Polymorphism: Polymorphism is an important concept in Object-oriented programming. It refers to the ability of code to behave differently based on the data that it is given. It involves defining different implementations of the same method or function, thus allowing the code to take on different forms. An example of polymorphism in OOP would be a method called Fly() which is defined in the Animal class and can take on different forms based on the type of Animal object it is being called for.",374,218,"{0: ‘Inputs missing.’, 1: ‘Outputs missing.’, 2: 'Randomness as additional rule is missing.'}",1,"KC,KH","class inheritance,method overriding,OOP","randomness,user interface design,exception handling,input/output handling",
12,"Identify the required programming concepts for following task: ""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""
For each concept give a general explanation with an example.",3,"- Object-oriented programming: Object-oriented programming is a programming paradigm based on objects, which contain data fields and methods. It allows for the reuse of code and provides an efficient way of creating software. An example of object-oriented programming is creating a class for a type of organism, which contains fields such as size, color, diet, and methods for feeding, reproducing, and hunting.

- Classes: Classes are templates used to create objects that contain data fields and methods. An example of a class would be a Plant class, with fields such as size, rate of growth, and reproduction, and methods to calculate the available space in a habitat and set the size of a plant.

- Objects: Objects are instances of classes and contain data fields and methods. In the example, an object of the Plant class would contain data fields such as size, color, rate of growth, and reproduction, and methods for setting the size and calculating the available space in a habitat. 

- Encapsulation: Encapsulation is a technique used to keep data and methods together in a single unit. It allows classes and objects to manipulate their data internally and not expose it to the outside world, thus protecting data integrity. An example of encapsulation is in the organism class, which contains methods for feeding, reproducing, and hunting, but these are not exposed to outside sources.

- Inheritance: Inheritance is a technique used to create object-oriented classes from existing classes. This allows objects to inherit methods and properties from their parent classes, thus avoiding code duplication and increasing code reuse. An example of inheritance is the Animal class which inherits methods and properties from the Organism class.

- Abstraction: Abstraction is a technique used to simplify complex systems by hiding irrelevant details and exposing only the essential information. This simplifies programming and hides implementation details. An example of abstraction is the Plant class which has a single method for calculating the available space in a habitat, but hides the details of how it does this.

- Polymorphism: Polymorphism is a technique used to allow objects to be treated differently based on their type. An example of polymorphism is the Plant class which contains different methods for calculating the available space in a habitat depending on the type of plant.",377,251,"{0: ‘Inputs missing.’, 1: ‘Outputs missing.’, 2: 'Randomness as additional rule is missing.'}",1,"KC,KH","class inheritance,method overriding,OOP","randomness,user interface design,exception handling,input/output handling",
0,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Task: Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum.

Inputs: 
- Bank code (Bankleitzahl)
- Account number (Kontonummer)
- Country code (optional)

Outputs: 
- Complete IBAN (International Bank Account Number)
- Checksum
- Explanation of the complete IBAN

Constraints: 
- Inputs from the user must be in a valid format.
- Output messages must properly inform the user. 
- Error messages should be accordingly displayed if invalid input is entered. 

Programming Concepts:
- Variables: Variables are reserved storage locations used to store data. In this task, variables may be used to store strings, numeric values or boolean values. 
  *Example:  count = 5 # count stores an integer 
- Arithmetic Operations: Arithmetic operations are mathematical operations that are used to perform numerical calculations. In this task, arithmetic operations may be used to calculate the checksum for the IBAN. 
  *Example: sum = 5 + 7 #sum stores the result of the addition of 5 and 7 
- Input and Output: In this task, input and output statements such as the ‘input()’ and ‘print()’ functions are used to allow for user input and output to the program.  
  *Example: number_1 = input(""Please enter the first number: "") # number_1 stores user input 
- Control Flow & Loops: Control flow statements and loops are used to direct the execution of code based on conditionals. In this task, control statements and loops could be used to determine if the user correctly entered all the values (bank code, account number, etc) and to display error messages. 
  *Example:  if (x > 0): #if the value of x is greater than 0, then... 
- String Operations: String operations are used to manipulate strings such as concatenation or formatting. In this task, string operations may be used to properly format the IBAN for output. 
  *Example: iban = ""DE"" + bankCode + accountNumber #concatenates the strings DE, bankCode and accountNumber 

Code Structure: 
- Ask for the bank code (Bankleitzahl)
- Ask for the account number (Kontonummer)
- Ask for the country code (if not hard coded)
- Calculate the checksum for the IBAN
- Format the IBAN
- Print explanation
- Print the complete IBAN including the checksum",350,199,{},1,"KC,KH,KTC","input/output handling,string manipulation,comments,variables,conditionals",documentation,conditionals
0,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs: Bank code (Bankleitzahl) and account number (Kontonummer), country code (optional).

Outputs: Complete IBAN including the checksum.

Constraints: Must use Python 3.x, must include meaningful prompts, must include comments to improve structure and readability.

Programming Concepts: Variables, Input & Output, Flow Control, Commenting.

Code Structure:

#This program accepts a bank code (Bankleitzahl) and an account number (Kontonummer) 
#and outputs the complete IBAN including the checksum.

#Define variables
bank_code = """"
account_number = """"
country_code = """"

#Prompt for Bankleitzahl and Kontonummer
#Hard code the country code DE
bank_code = input(""Please enter the Bankleitzahl: "")
account_number = input(""Please enter the Kontonummer: "")
country_code = ""DE""

#Calculate checksum of IBAN
#Refer to https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits
checksum_calculation = """" 

#Generate complete IBAN including checksum
complete_IBAN = """"

#Print complete IBAN
print(complete IBAN)",121,79,{},1,"KC,KH,KMC","variables,input/output handling,comments,conditionals","string manipulation,documentation",conditionals
0,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that accepts a bank code (Bankleitzahl) and an account number (Kontonummer). The program should output and explain the complete IBAN (International Bank Account Number) including the checksum. For beginners, it is sufficient to hardcode the country code ""DE,"" but if desired, the program can also prompt for the country code as an additional input.

Instructions for calculating the checksum can be found at:
https://en.wikipedia.org/wiki/International_Bank_Account_Number#Check_digits

Additional guidelines or requirements:
 - Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
 - Use comments in the code to improve structure and readability.
 - Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: 
- Bank Code (Bankleitzahl): This is a numeric identifier, usually 8 digits long, for a particular bank in Germany.
- Account Number (Kontonummer): This is a longer numeric or alphanumeric identifier, usually 10 digits long, associated with a bank account.
- Country Code (optional): An two-letter code to identify the country associated with the banking system. For this task, the country code is given as ""DE,"" for Germany.  

Outputs: 
- International Bank Account Number (IBAN): This is a longer alphanumeric identifier, up to 34 digits long, comprises of a country code, a two-digit checksum, a four-digit bank code, and an account number.

Constraints: 
- The program should be written in Python 3.x
- Ensure that input prompts adequately inform the user about what they should enter and its significance. The same applies to output messages.
- Use comments in the code to improve structure and readability.
- Address in the documentation which inputs are not allowed and may lead to error messages (if not already handled)

Programming Concepts: 
- Variables: Variables are containers for storing data values.  A variable stores a piece of data and gives it a specific name making it easier to refer to the data later in the program. For example: `country_code = ""DE""` 
- Strings: A string is a sequence of characters, which can be used to represent words or phrases in Python. For example: `name = ""John Smith""` 
- Conditionals: Conditionals are statements in code that can check whether certain conditions are true or false, and execute code in response. For example: 
`if country_code == ""DE"":
  print(""Processing German bank codes"")` 
- Functions: Functions are blocks of code that group together code with the same purpose and can be executed from multiple places within a program. For example:
`def calculate_checksum(iban_value):
  ...
  return checksum`

Code Structure:
# Prompt user for inputs
bank_code = input(""Please enter the bank code: "")
account_number = input(""Please enter the account number: "")
country_code = input(""Please enter the country code (optional): "")

# Set default values
if country_code == """":
    country_code = ""DE""

# Calculate checksum
checksum = calculate_checksum(country_code+bank_code+account_number)

# Format IBAN 
iban = country_code+checksum+bank_code+account_number

# Output results
print(""The IBAN associated with the bank code "" + bank_code + 
      "" and the account number "" + account_number + "" is "" + iban + ""."")",355,213,{},1,"KC,KH,KTC,KMC","functions,input/output handling,string manipulation,comments,variables,conditionals",documentation,"functions,conditionals"
1,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: 
The input in this task is the year that will be read from the console.

Outputs:
The output will be a message displayed in the console. The message will be a complete sentence that states whether the year is a leap year in the Gregorian calendar or not.

Constraints:
The program must use Python 3.x and abide by the rules for leap years in the Gregorian calendar (see provided link). 

Required Programming Concepts:
The required programming concepts for this task include variables, conditional statements, and print statements. 

Variables: Variables are used to store data within a program. In this case, the program will need a variable to store the year that is input from the console. The variable name for the year could be ""year"". 

Conditional Statements: Conditional statements are used to execute code whenever a certain condition is met. In this case, the code needs to check whether a year given is a leap year. Specific conditions must be checked in order to determine this, such as if the year can be divided by 4. 

Print Statements: Print statements are used to display the output to the console. In this case, the program needs to print a sentence that states whether this year is a leap year or not. 

Code Structure:
year = int(input(""Please enter a year:"")) 

if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): 
  print(""The year "" + str(year) + "" is a leap year."")

else:
  print(""The year "" + str(year) + "" is not a leap year."")",253,154,{},1,"KC,KH,KTC","variables,input/output handling,conditionals,string manipulation",,
1,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Input:

The input for this task is a year in the Gregorian calendar. This will come from the console.

Output:

The output for this task will be a sentence stating whether the year entered is a leap year or not.

Constraints:

The program must be written in Python 3.x, and should follow the rules for leap years in the Gregorian calendar as stated on the Wikipedia page given in the task.

Programming Concept:

1. Variables: Variables are labels we give to certain values or datasets. Each value is stored within a variable and can be referenced later in our code. For example, we might define a variable called `year` to store the year entered in the console. 

2. Conditional Statements: Conditional Statements allow us to match certain data with certain conditions. The program can then take action accordingly. For example, we could use a conditional statement to check if a given year meets the criteria for a leap year according to the Gregorian calendar. 

3. Print Statements: Print Statements provide a way to output data from our program into the console. In our program, we will need to use print statements to output the sentence stating whether or not our year is a leap year. 

Code Structure:

def is_leap_year(year): 
  # Use a conditional statement to check the criteria for a leap year
 
  # Use a print statement to output the sentence stating whether 
  # the year is a leap year or not

# Create a variable to store the year entered in the console 
year = input(""Enter a year: "")

# Call the function with the stored year 
is_leap_year(year)",266,153,{},1,"KC,KH,KTC","functions,variables,input/output handling,conditionals",string manipulation,functions
1,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that reads a year from the console and determines whether it is a leap year in the Gregorian calendar. Display the result in the console as a complete sentence, such as ""The year 1993 is not a leap year."" or ""The year 2024 is a leap year.""

You can refer to the rules for leap years here:
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: 
The input to the program will be a year, entered by the user via the console. 

Outputs: 
The output of the program will be a sentence, displayed in the console, stating whether the year provided by the user is a leap year according to the Gregorian calendar, or not.

Constraints: 
The input year must be a valid year within the Gregorian Calendar.

Required Programming Concepts: 
1. Variables: Variables are used to store and manipulate data. They can be used to store user input and to calculate the output of the program. In this case, we will use a variable to store the year input by the user and another to store the output of the program. 

2. Console Input/Output: Console Input and Output statements are used to interact with the user. For this task, we will use the “input()” function to prompt the user to enter a year and the “print()” function to display the program’s output sentence in the console.

3. Conditional Statements: Conditional Statements are used to execute certain blocks of code based on the evaluation of a certain boolean expression. In this task, we will use conditional statements (e.g. if, elif, else) to determine whether the year entered by the user is a leap year or not, according to the rules provided.

Code Structure:
year = input(""Please enter a year: "")

#calculate if year is leap year or not 
if (year % 400 == 0):
    leap_year = True
elif (year % 100 == 0):
    leap_year = False
elif (year % 4 == 0):
    leap_year = True
else:
    leap_year = False

#display output
if leap_year:
    print(""The year ""+str(year)+"" is a leap year."")
else:
    print(""The year ""+str(year)+"" is not a leap year."")",280,151,{},1,"KC,KH,KTC","variables,input/output handling,conditionals",string manipulation,
2,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Task: Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not.

Inputs: Whether the year is a leap year or not.

Outputs: The minimum and maximum number of ""Friday the 13th"" occurrences in a given year.

Constraints: The program should provide clear and understandable output. 

Required Programming Concepts:
1. Conditionals (e.g. if-statements)
- Conditionals are programming concepts that allow us to check whether a certain condition is met. If it is met, a particular set of instructions can be executed; if not, a different set of instructions can be executed. Conditionals enable us to make decisions in our code: the flow of the code changes based on the outcome of the conditional statement.

2. Loops 
- Loops are a type of control structure which allows us to execute a set of instructions multiple times. There are several types of loops available, such as for loops, while loops, and do-while loops. They can be used to repeat a set of instructions for a fixed number of times, until a certain condition is met, or even until the loop is manually broken.

3. New feature in Python 3.10 (match-case feature)
- The new match-case feature in Python 3.10 is a powerful new tool which allows us to use switch-case statements in Python. This allows us to check multiple conditions and take different actions depending on the outcome.

Code Structure:

#Initialize min and max
min_friday = 0
max_friday = 0

# Read input 
year = input('Is this a leap year or a non-leap year? Enter ""leap"" or ""non-leap"":') 

# Use new match-case feature in Python 3.10 to check the input 
match year:
    case 'leap':
        # Compute the min and max number of friday the 13th, using a loop
    case 'non-leap':
        # Compute the min and max number of friday the 13th, using a loop 

# Print the output
print('The minimum friday the 13th in this year is {} and the maximum friday the 13th in this year is {}'.format(min_friday, max_friday))",353,231,{2: 'The importance of the starting weekday of the year is missing'},1,"KC,KH,KTC","loops,input/output handling,conditionals","variables,string manipulation",
2,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Task: Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. 

Inputs: user input for leap year or non-leap year

Outputs: minimum and maximum number of ""Friday the 13th"" occurrences in a year

Constraints: The program should provide clear and understandable output.

Programming Concepts: 

1. Iteration: Iteration is the process of repeating a set of instructions multiple times. In this task, you will need to be able to repeat a process multiple times to calculate the minimum and maximum number of Friday the 13th's in a year.

Example:

for i in range(10):
  print(i)

2. Date/Time: This program deals with carrying out calculations on dates and times, so knowledge of how to handle dates and times within Python is important. Using the datetime package, you can use built-in functions to manipulate dates, times, and timestamps. 

Example:
from datetime import datetime

today = datetime.now()
print(today.day, today.month, today.year)  

3. Conditional Statements: Conditional statements are used to perform different actions based on different conditions. In this task, you will need to be able to use conditional statements to control the flow of the program so that it works properly. 

Example:
age = 10

if age > 18:
  print(""You can vote!"")
elif age == 18:
  print(""You can vote in some countries!"")
else:
  print(""You can't vote!"")

4. Random Numbers: Random numbers are used to generate truely random values. In this task, you will need to use random numbers to generate random dates.

Example:

import random

random_date = datetime.date(random.randint(2000,2025), random.randint(1,12), random.randint(1,28))
print(random_date)

Code Structure:

# Ask user if they want to calculate for a leap year or a non-leap year
year_type = input(""Leap year or non-leap year? (L/N)"")

# Set counters
min_count = 0
max_count = 0

# Iterate through all days in given year
for day in range(1, 366): 
  # If it is Friday the 13th, increment count 
  if day % 7 == 5 and day % 13 == 0:
    count +=1 
  # If it is the last day of the year 
  if day == 365:
    # Set the min count to the current count if it is lower
    if count < min_count: 
      min_count = count
    # Set the max count to the current count if is higher
    if count > max_count: 
      max_count = count

# Print out the min and max counts
print(""The minimum number of Friday the 13ths is: "" + min_count)
print(""The maximum number of Friday the 13ths is: "" + max_count)",426,240,{2: 'The importance of the starting weekday of the year is missing'},"1: ""Calculates the minimum and maximum number of 'Friday the 13th' wrong.""","KC,KH,KTC","loops,input/output handling,variables,conditionals,iteration/recursion",string manipulation,iteration/recursion
2,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Tips:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts.
 - You can try using the new match-case feature in Python 3.10.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Task:
Create a Python 3.x program that calculates the minimum and maximum number of ""Friday the 13th"" occurrences in a year, taking into account whether it is a leap year or not. The user can input whether they want to calculate for a leap year or a non-leap year. The program should provide clear and understandable output.

Inputs:
 - User input whether they want to calculate for a leap year or a non-leap year

Outputs:
 - The minimum and maximum number of ""Friday the 13th"" occurrences in a year

Constraints:
 - The number of ""Friday the 13th"" occurrences in a year depends on the weekday on which the year starts

Required Programming Concepts:
 - Control Structures
 - Data Types
 - Date and Time Module
 - Conditionals
 - Loops

Code Structure: 
def main():
    #handle user input
    #calculate minimum and maximum number of Friday the 13th occurrences in a year
    #output results
 
if __name__ == ""__main__"":
    main()

Acting as a teacher, explanation with examples for each concept:

Control Structures: Control structures are a set of statements used to control the flow of a program. Control structures involve making decisions and repeating or looping over a set of instructions. Examples of control structures are: if, else, while loops, and for loops. 

Data Types: Data types are the classification of different kinds of data. For example, in Python, string, integer, and float are all different data types. They are defined by the type of data that they hold.

Date and Time Module: The Date and Time module provides a set of functions for storing and manipulating dates and times. This module includes functions to validate dates, generate date strings, and store dates in different formats. For example, one function in the Date and Time module is the datetime.time() function, which creates a time object with the current time.

Conditionals: Conditionals are a type of control structure used to check if a statement is true or false. Conditionals are often implemented using “if” statements. If a statement is true, then a block of code is executed. For example, the following code checks if the number 5 is less than 7 and prints “5 is less than 7” if it is true:
    
if 5 < 7:
    print(""5 is less than 7"")

Loops: Loops are another type of control structure used to repeat a set of instructions multiple times. For example, a “for” loop can be used to iterate through a list and print each item:

for item in list:
    print(item)

In this example, the code in the loop block will be repeated for each item in the list.",428,237,{2: 'The importance of the starting weekday of the year is missing'},1,"KC,KH,KTC","functions,loops,input/output handling,conditionals,modules,time","variables,string manipulation","functions,modules,time"
3,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: In subtask a, no inputs. In subtask b, inputs is the position of the queen. 

Outputs: In subtask a, a chessboard displayed in console. In subtask b, an updated chessboard displayed in console with a queen placed on the specified position.

Constraints: The queen must be placed within the 8x8 chessboard.

Required programming concepts:
- Functions: a way to bundle logically related code for easy and/or repeated use
    For example, to create a function:
        def greeting(): 
            print('Hello!')

- Parameters: allows a function to accept varying inputs
    For example, to create a function with a parameter:
        def greeting(name): 
            print(""Hello "" + name)

- Calling a Function: the action of executing the commands within a function 
    For example, to call a function:
        greeting()

Code Structure for Subtask a): 

def chessboard():
    # code for chessboard
   
chessboard() # function call

Code Structure for Subtask b): 

def chessboard():
    # code for chessboard
    
def queen_on_chessboard():
    # code for queen_on_chessboard
    
chessboard() # function call
queen_on_chessboard() # function call",155,111,{0: 'Mentioning of default value for position of queen is missing.'},1,"KC,KH,KTC",functions,"input/output handling,string manipulation,conditionals,loops",
3,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs:
a) No inputs 
b) Position of queen

Outputs:
a) 8x8 chessboard with each square labeled
b) 8x8 chessboard with queen placed at a certain square labeled

Constraints:
None

Programming Concepts:
a) print() - This is a Python function that allows us to print strings or other objects to the terminal. We can use it to display the chessboard with the square labels.
Example: print(""A1"")

b) Function definition - This is used to define the code that would run when calling a certain function name. It's like giving a name to a whole code block.
Example: 
def functionName(): 
  print(""This code will execute when calling this function"")

Code Structure:
a)
def chessboard(): 
  # logic to generate and display chessboard
  
chessboard()

b)
def queen_on_chessboard(position): 
  # logic to generate chessboard and place queen
  
queen_on_chessboard(position) # position being the position of the queen",139,88,{0: 'Mentioning of default value for position of queen is missing.'},0: “no default parameter in b)”,"KC,KH","functions,string manipulation","input/output handling,conditionals,loops",
3,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create executable Python 3.X code (in a .py file) for each subtask a) and b).
In a classic 8x8 chessboard, the rows are labeled with numbers from 1 to 8, and the columns are labeled with letters from A to H. Therefore, each of the 64 squares can be uniquely identified by a combination of a number and a letter.

a) Create a function named ""chessboard"" that generates a chessboard by displaying each square with its corresponding label (as shown in the illustration on the right) in the console. Include the function call below the function definition.

b) Create a function named ""queen_on_chessboard"" that takes the position of a queen as input and displays the queen (using a symbol such as ♛ or QQ) at the corresponding square on the chessboard. In the illustration on the right, you can see an example with the queen placed on square B4. If no parameter is passed to the function, it should exhibit the same behavior as the function in subtask a).""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs:
a) No inputs are needed for the chessboard function
b) The position of the queen as input for the queen_on_chessboard

Outputs:
a) A chessboard printed in the console with each square labeled
b) A symbol representing the queen on the chessboard in the corresponding square

Constraints:
The chessboard is a classic 8x8 with rows labeled from 1-8 and columns labeled from A-H
The symbol used for the queen must be consistent

Programming Concepts:
a) Create a function - A function is a reusable block of code that can be used multiple times. The function's name is created to help the programmer easily identify and understand the code within it. To create a function, ""def"" followed by the name of the function and any parameters that it takes is written. For example, 'def hello_world():'. 
b) Loops - Loops are used when a block of code needs to be executed multiple times. There are two main types of loops – for loops and while loops. A for loop will allow items within a sequence (list, tuple, etc.) to be iterated over. A while loop will continue to execute until a certain condition is met. 

For example,

###Task a

#Create a function named ""chessboard"" 
def chessboard(): 

  #Use loop to iterate through rows
  for i in range(1, 9): 

    #Use loop to iterate through column
    for j in range(1, 9): 
      
      #Print the chessboard with corresponding letter and number 
      print(chr(i+64)+str(j)) 
  
#Function call 
chessboard()


###Task b

#Function to Place Queen on Chessboard
def queen_on_chessboard(position): 

  #Use loop to iterate through rows
  for i in range(1, 9): 

    #Use loop to iterate through column
    for j in range(1, 9): 

      #If the position of the queen matches the row and column prints the queen
      if (i+64) == position[0] and str(j) == position[1]:
        print('♛')
      #Print the chessboard with corresponding letter and number 
      else:
        print(chr(i+64)+str(j)) 
  
#Function call with position of queen
queen_on_chessboard('B4')",328,215,{0: 'Mentioning of default value for position of queen is missing.'},0: “no default parameter in b)”,"KC,KH,KTC","functions,loops,conditionals,string manipulation",input/output handling,
4,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: The input will be two players, and a number of matchsticks to begin with (13 in this case).

Outputs: The output should be a visual representation of the game and who has won the game once the last matchstick is taken.

Constraints: The players can only take one, two, or three matchsticks. 

Programming concepts: This task requires the use of variables, strings, functions, loops, and if/else statements.

Code structure:
# Main function of the game:
def matchsticks_game():
  # Initialize matchsticks to 13
  matchsticks = 13

  # While loop to make sure the game ends when someone takes the last matchstick
  while matchsticks > 0:
    # Player 1's turn
      # Let player 1 decide to take 1, 2, or 3 matchsticks
      # Subtract amount of matchsticks taken from the total
    # Player 2's turn
      # Let player 2 decide to take 1, 2, or 3 matchsticks
      # Subtract amount of matchsticks taken from the total
    
    # Function to visualize matchsticks
    def visualize_matchsticks(matchsticks):
      # Print out the number of matchsticks
      print(""There are %d matchsticks remaining!"" % matchsticks)
      # Decide whether to use '*' or '|' to output the visual representation
        # For loop to iterate through each of the matchsticks and print out '*' or '|' depending on how many matchsticks are remaining
    # Check if anyone has won by seeing how many matchsticks are remaining
    if matchsticks == 0:
      print(player + "" has won the game!"")
  
  # End matchstick game

# Call matchstick game to start playing
matchsticks_game()",228,143,"{0: ""Player input each turn is missing.""}",1,"KC,KH,KTC","functions,loops,input/output handling,variables,conditionals",string manipulation,variables
4,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs: 
- User input from two players
- Number of remaining matchsticks

Outputs:
- Visual representation of remaining matchsticks
- Winner of the matchstick game

Constraints:
- Players can only take 1, 2, or 3 matchsticks
- Player has to take last matchstick to win

Programming Concepts:
1. Control Flow: 
  - Control flow structures, such as conditionals (if-else) and loops (for-while) will be used to prompt the players for input and to take the appropriate action, such as declaring a winner.

2. Functions: 
  - A separate function will be used to visualize the matchsticks. This function will take the remaining matchstick as a parameter and will be called when the input from a player is received.

3. User Input:
  - The two players will be prompted to provide either 1, 2, or 3 matchsticks. The player input will be used to subtract the number of matchsticks on the table which will in turn be used as a parameter to the matchstick visualization function. 

Code Structure:
def visualiseMatchsticks(numSticks):
  # Draws the visual representation of remaining matchsticks

  # Code for drawing the matchsticks


def main():
  numSticks = 13
  numPlayer = 1
  
  while numSticks > 0:
    if numPlayer == 1:
      print(""Player 1: Enter number of matchsticks to remove"")
      numRemove = int(input())
      numPlayer = 2
    else:
      print(""Player 2: Enter number of matchsticks to remove"")
      numRemove = int(input())
      numPlayer = 1
    
    numSticks -= numRemove

    visualiseMatchsticks(numSticks)
    
  if numPlayer == 2:
    print(""Player 1 wins!"")
  else:
    print(""Player 2 wins!"")


if __name__ == ""__main__"":
  main()",234,139,{},1,"KC,KH,KTC","functions,loops,input/output handling,variables,conditionals",string manipulation,variables
4,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""In the matchstick game, there are initially 13 matchsticks on the table. Two players take turns removing one, two, or three matchsticks. The person who takes the last matchstick wins. Implement this game in Python 3.X. The remaining matchsticks should be visually represented with suitable output in the console. The two players will be prompted alternately to take one to three matchsticks until one of the players takes the last matchstick. The program should then display which player has won.

Create a separate function for visualizing the matchsticks, which takes the number of remaining matchsticks as a parameter. Be creative in designing the output.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: Number of matchsticks, how many matchsticks a player wants to take, how many matchsticks remain on the table 

Outputs: A visual representation of matchsticks, which player has won.

Constraints: Players must take one, two, or three matchsticks each turn and the game ends when the last stick has been taken. 

Programming Concepts: Function, user input, looping, if-else statements

Code Structure: 

def display_matchsticks(remaining):
    # Create visual representation of matchsticks here 

def play_matchsticks(number_matchsticks):
    # Game loop to prompt users and check winner 
    while True:
        # prompt user 1 to pick 1-3 matchsticks
 
        # decrement the number of matchsticks 

        # check if the user has won 

        # if not, switch to player 2 and repeat the steps 
        

Explanation of Programming Concepts: 

Function: A function is a block of organized, reusable code that is used to perform a single, related action. Functions allow us to break a task into smaller, more manageable parts. For example, if we wanted to find the average of three numbers, we can create a function to calculate it for us. 

User Input: User input allows a program to accept input from the user. Most commonly, it involves prompting the user to type values into the console, which can then be stored in variables. For example, if the user is asked to input their name, the program can store it in a variable and use it in the program for output. 

Looping: Looping is used to repeat a set of instructions until a certain condition is met. For example, if we wanted to add the numbers from 1-10, we can use a loop to iterate over those numbers and add them together. 

If-Else Statements: An if-else statement is used to execute a set of instructions based on a certain condition. If the condition is true, then the code in the if-statement block is executed, otherwise, the code in the else-statement is executed. For example, if we wanted to check if a number is odd or even, we would use an if-else statement to evaluate the condition and print the correct output.",346,175,{},1,"KC,KH,KTC","functions,loops,input/output handling,conditionals",string manipulation,
5,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: Console input (in Task 2) specifying which module to run, parameters as needed (e.g. length for Password Generator).

Outputs: For Task 1, binary representations of positive integers, difference in time as a string in the required format (days, hours, minutes), Boolean value for Open Course Pages, Random password in the required format.

Constraints: Positive integers only for Binary Calculator; timezone differences not taken into account for Exam Countdown; only three courses need to be implemented for Open Course Pages.

Programming Concepts: Module creation, calculation with time/date data (Module ""time""), generation of random numbers (Module ""random""), conversion of numbers to letters (ASCII table), usage of ""return"" and ""display"" correctly.

Code Structure

Task 1, Binary Calculator:

# import default Python module
import time 
# define function ""decimal_to_binary""
def decimal_to_binary(num):
   # create a list for binary values
   binary_values = [] 
   # create a loop to calculate binary number
   while num > 0:
       binary_values.append(num % 2)
       num = num // 2 
   # reverse the binary values list
   binary_values = binary_values[::-1] 
   # convert list of binary to string
   binary_string = """".join(str(x) for x in binary_values) 
   # print list of binary
   print(binary_string)
   # return string binary
   return binary_string 
   
Task 2, Program:

# import module from task 1
import eprtools

# ask for input to select which tool to use
tool_selection = input(""Which tool do you want to use? Enter 'a', 'b', 'c', or 'd': "")

# use if-elif-else to check input and use the correct tool
if tool_selection == 'a':
   num = int(input(""Enter a positive integer: ""))
   decimal_to_binary(num)
elif tool_selection == 'b':
   # get parameter of timestamp
   timestamp = input(""Provide a timestamp, or leave empty for current system timestamp: "")
   # if timestamp is empty, get current system timestamp
   if timestamp == '':
      timestamp = time.time()
   exam_countdown(timestamp)
elif tool_selection == 'c':
   abbreviation = input(""Provide a course abbreviation: "")
   open_course_page(abbreviation)
elif tool_selection == 'd':
   length = input(""Provide a password length: "")
   password_gen(length)
else:
   print(""Error - Invalid tool selection"")",306,222,"{1: ""Step-by-step display in the console for the 'decimal_to_binary' function is missing""}","0: ""Step-by-step display in the console for the 'decimal_to_binary' function is missing”","KC,KH,KTC","functions,loops,input/output handling,string manipulation,variables,conditionals,randomness,modules,time,lists",,"variables,time,lists"
5,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs: User command line input, the module eprtools.py 

Outputs: Console output displaying either the binary conversion, the countdown clock info, the webpage, or the random password.

Constraints: The modules must follow the given specifications and must be written in Python 3.X. 

Programming Concepts:

1. Module importation: the task requires the importation of two modules, the first being ‘eprtools.py’ which the user will have to write. This is done using the ‘import’ command. For example:

import eprtools

2. Parameter handling: all four functions in the module require parameters (integers, strings, etc). These parameters will need to be handled appropriately in order for the functions to behave correctly.

3. Modules: this task requires knowledge of the time, webbrowser, and random modules that are built into Python. These modules can be imported using ‘import’. Additionally, they contain several useful functions which are necessary to complete the task. For example, the time module contains the ‘time()’ function which returns the current system time in seconds. 

4. Console input and output: for this task, user input is required (through the console) in order to determine which tool should be executed. Similarly, all four functions will need to produce output (which will be displayed in the console). This is handled using the input() and print() functions, respectively.

Code Structure: 

#import the necessary modules 
import eprtools
import time
import webbrowser
import random

#loop until the user decides to quit
while True:
    #prompt the user for input
    user_input = input(""What tool would you like to use? (0 to quit): "")
    
    #exit the loop if the user input is 0
    if user_input == 0:
        break
        
    #if the user input is 1, call the 'decimal_to_binary' function from the eprtools module
    elif user_input == 1:
        eprtools.decimal_to_binary()
   
    #if the user input is 2, call the 'exam_countdown' function from the eprtools module
    elif user_input == 2:
        eprtools.exam_countdown()
        
    #if the user input is 3, call the 'open_course_page' function from the eprtools module
    elif user_input == 3:
        eprtools.open_course_page()
        
    #if the user input is 4, call the 'password_gen' function from the eprtools module
    elif user_input == 4:
        eprtools.password_gen()
        
    #prompt the user to enter a valid command if they enter an invalid command
    else:
        print(""Please enter a valid command."")",364,267,"{2: ""The constraint regarding time zones not needing to be taken into account for the 'exam_countdown' function is missing""}",1,"KC,KH,KTC","functions,loops,input/output handling,conditionals,modules","string manipulation,randomness",
5,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Task 1:

The standard installation of Python 3.X includes a wide range of modules that provide helpful functions. These so-called built-in modules can be imported and used without further installations. In this task, you will get to know some of these modules and also write your own module to be imported later.
Create a Python module named ""eprtools.py"" and implement the following functions within this module. Pay attention to the difference between ""return"" and ""display"".

a) Binary Calculator
Implement a function called ""decimal_to_binary"" that takes a positive integer as an argument and returns a string representing its binary representation. Additionally, step-by-step conversion should be displayed in the console, following the schema learned in GPR.

b) Exam Countdown
In a function named ""exam_countdown"", calculate the time between a given timestamp and the first EPI exam on February 16, 2023, at 10:00 AM. Then, display the difference in the console in the format ""_ days, _ hours, _ minutes"" (you can disregard units smaller than minutes, so rounding is not necessary).
If no timestamp is provided, use the current system timestamp.
To easily work with time and calendar data, refer to https://unixtime.org/ to learn about Unix time and Unix timestamp. You can use the ""time"" module in Python to obtain the current Unix timestamp.
Utilize the ""time"" module and Unix timestamp to calculate the remaining time. Time zones do not need to be taken into account.
Documentation for the ""time"" module: https://docs.python.org/3/library/time.html#module-time

c) Open Course Pages
For quick access to the various course websites of your attended lectures, implement a function called ""open_course_page"" that takes a module abbreviation (e.g., ""EPR"", ""MOD"", ""LinADI"", etc.) as a parameter and opens the corresponding Moodle course or course webpage in a web browser. Implement this for at least three courses. If a valid abbreviation is provided, the function should return True; otherwise, it should return False. Use the ""webbrowser"" module in Python for this task.
Documentation for the ""webbrowser"" module: https://docs.python.org/3/library/webbrowser.html#modulewebbrowser

d) Password Generator
Create a function called ""password_gen"" that takes the parameter ""length"" and generates and returns a random password of the specified length, consisting of digits 1 to 9 and uppercase and lowercase letters from A to z. Use the ""random"" module in Python to generate (pseudo-)random numbers. You can convert these random numbers into letters using the ""chr(i)"" function based on an ASCII table, for example.
Documentation for the ""random"" module: https://docs.python.org/3/library/random.html#module-random

Task 2:
Write a Python 3.X program (in a separate Python file) that imports the module ""eprtools.py"" created in Task 1. Through console input, the user should be able to choose which of the four implemented tools should be executed. If necessary, any required parameters should be queried through the console.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: The input for this task is a positive integer, an abbreviation (e.g. ""EPR"", ""MOD,"" etc.), the length of a password, and user input for which of the four tools should be executed.

Outputs: The outputs of this task are the binary representation of a given number, a countdown of days, hours, and minutes until a specific date, True or False depending on whether or not a valid abbreviation was provided, and a randomly-generated password based on user input for length.

Constraints: Time zones do not need to be taken into account.

Programming Concepts: The programming concepts used in this task include the use of the “time” module in Python for obtaining the current Unix timestamp, the “webbrowser” module for opening a course page in a web browser, and the “random” module for generating a random password. 

Code Structure:

import time
import webbrowser
import random

def decimal_to_binary(pos_int):
    # code to convert a positive integer to binary and display step-by-step conversion

def exam_countdown():
    # code to calculate the time between a given timestamp and the first EPI exam on February 16, 2023

def open_course_page(module_abbr):
    # code to open the corresponding Moodle course or course webpage for given module abbreviation
    return # True/False

def password_gen(length):
    # code to generate a random password of the specified length

if __name__ == '__main__':
    # user input to choose which tool to execute
    # call corresponding function with required parameters",234,207,"{0: ""Timestamp for exam countdown not mentioned in inputs.""}",1,"KC,KH,KTC","functions,input/output handling,conditionals,randomness,modules,time","string manipulation,loops",time
6,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: The inputs for this task are the strings of the 20 cards, an array containing the positions of the two cards, and user input for choosing two cards. 

Outputs: The outputs are the game grid, the motifs of the two cards, the modified grid after removing the cards, and the number of rounds required in the end.

Constraints: The current game grid should be displayed correctly following the positions of the two cards, incorrect user inputs should be handled.

Required Programming Concepts:

Nested Lists:A nested list is a Python list inside another Python list. It is a container that holds other containers (i.e. lists). The structure of the nested list is shown below:
[list1, [list2], [list3], ...]
The above example shows a nested list with three lists as elements. To access elements in nested lists, use the multi-index syntax:
list[index1][index2]

Tuples:A tuple is an immutable Python data type. It means that once defined, the list of tuples elements can’t be changed. Tuples are created using parentheses ""()"" and with elements separated by commas. An example of a tuple is: 
tuple = ('a','b','c','d')
To access the elements of a tuple, use the index syntax to access elements:
tuple[index] 

Loops:Loops can be used in Python for iterating though lists, strings, dictionaries, and other data structures. Loops are useful for iterating over sequences, performing repetitive tasks, and running many iterations of a code block. The two most common types of loops are for and while loops. For example:

For Loop: 
for item in list:
    code block

While Loop:
while condition is true:
    code block

Conditionals:
Conditionals control how the code block is executed. An example of a conditional would be an 'if statement'. If statements evaluate whether or not a condition is true before performing an action. 
For example: 

if condition is true:
    code block

Drawing:
In this task, the program must draw the game grid. To do this, the program must be able to iterate over the game grid and draw the symbols in the correct positions.

Code Structure:
import memory 

# create the grid
cards = memory.create_grid(CARDS)

while cards not empty:
  # draw the grid
  memory.draw_grid(cards)

  # wait for user input
  pos1, pos2 = input('Input card positions:')

  # check if they are the same
  symbols = memory.get_symbols(cards, pos1, pos2)
  if symbols[0] == symbols[1]:
    # remove cards from game grid
    memory.take_cards(cards, pos1, pos2)

# at the end output the number of rounds
print('Number of rounds: ', num_rounds)",416,280,{},0: “Input unpacking does not fit function parameters.”,"KC,KH,KTC","functions,loops,input/output handling,variables,conditionals,exception handling,lists","string manipulation,randomness,modules,time",variables
6,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs: The grid (list of 20 cards, represented by strings) and the positions of two cards (pos1 and pos2).

Outputs: The created game grid, the motifs of two cards, a modified game grid accordingly to a pair that is found, a drawn game grid representation that can change whether two positions are provided. 

Constraints: The game grid must be 5x4 with 20 cards, all pair of cards must be the same symbol, an incorrect input should not cause the program to crash. 

Programming Concepts:
1. Functions: Functions are reusable pieces of code that can be called repeatedly to perform a specific task. In this case, create_grid(), get_symbols(), take_cards() and draw_grid() functions are required.

Example:
def create_grid(cards):
  #creating a 5x4 grid
  board = [] 
  for row in range(4): 
    board_row = [] 
    for column in range(5): 
      board_row.append(cards.pop(0))
    board.append(board_row)
  return board 

2. Nested Lists: Nested lists are a collection of lists within a main list. In this case a 2 dimensional nested list is needed to create the game grid. 

Example:
list_1 = [1, 2, 3] 
list_2 = [4, 5, 6] 
list_3 = [7, 8, 9] 

nested_list = [list_1, list_2, list_3]

3. Tuples: A tuple is an immutable sequence data type that consists of a number of values separated by commas.

Example:
my_tuple = (""Michael"", 23, ""Software Engineer"")

4. Logic Control Structures: Logic control structures are used to determine which code should be run under certain conditions, in this case the input parameters.

Example:
if (x < 15): 
  print(""x is greater than 15"")
else: 
  print(""x is lesser than 15"")

Code Structure: 
1. Import the memory.py module;
2. Create the game grid;
3. While not all pairs are found: 
    a. Draw the current game grid;
    b. User input of two cards;
    c. Reveal the chosen cards;
    d. Uncover the chosen cards;
    e. If a pair is found, take the cards from game grid;
4. Output the number of rounds required;
5. Prompt the user to start a new game.",327,227,"{0: ""Input from players are not listed.""}",1,"KC,KH,KTC","functions,loops,variables,conditionals,exception handling,lists","input/output handling,string manipulation,randomness,modules,time",variables
6,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Task 1 - Preparations:
First, create a Python module named ""memory.py"". In this module, you will define functions that will make it easier to implement the game in Task 2.

The Cards:
The game is played with 20 cards, with two cards having the same motif. Each card is represented by a string with a corresponding symbol. The 20 cards are grouped together in a list. The variable representing the 20 cards is as follows:
CARDS = [""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀"",
""✿"", ""❄"", ""★"", ""♥"", ""✉"", ""✂"", ""✖"", ""✈"", ""♫"", ""☀""]

a) Creating the Game Grid:
To start playing, the 20 cards need to be spread out. Implement the function create_grid(cards) to arrange the 20 cards in a 5x4 grid for the game board using nested lists. The function should return the created game grid, which represents the layout of the spread-out cards.

b) Flipping a Card:
When a player wants to flip two cards, the corresponding motifs of the cards need to be revealed. The function get_symbols(grid, pos1, pos2) should help with this. It takes the current game grid and the two card positions as input parameters. The function checks which motifs the two cards have and returns both as a tuple.

c) Removing a Card:
Once a pair is revealed, it needs to be removed from the game grid. Implement the function take_cards(grid, pos1, pos2), which takes the current game grid and the positions of two cards as input. The function should adjust the current game grid so that the corresponding positions on the grid are ""empty"". Think of a suitable method to mark the spot accordingly.

d) Drawing the Game Grid:
To provide an overview of the game grid and the remaining cards to the player, the (covered and uncovered) game cards need to be displayed in the console. Each card should be represented by a combination of a letter and a digit, corresponding to its position.
Implement the function draw_grid(grid, pos1=None, pos2=None) for this purpose. It takes the current game grid and optionally the positions of two uncovered cards as input. If only the game grid is provided, all remaining cards should be represented by their letter-digit combination. Pairs that have already been found should not be displayed anymore. If the positions are additionally provided, the motifs of the cards should appear at the corresponding positions on the game grid.
Remember to ""clear"" the console before outputting the grid so that previous moves are no longer visible. Outputting empty lines is sufficient for this purpose.


Task 2 - Game Logic:
In a separate Python file, implement the gameplay for a player. Import and use the functions from Task 1 for this purpose.
Gameplay:
	1. Shuffle the cards.
	2. Create the game grid (arrange the cards on the grid).
	3. Until all pairs are found:
		a. Draw the current game grid.
		b. The player chooses two cards.
		c. The cards are revealed for 3 seconds and then covered again.
		d. If a pair is found, the cards are removed from the game grid.
	4. Once all pairs are found, output the number of rounds required.
	5. The player has the option to start a new game.

Make your program robust, so that incorrect user inputs are handled and do not cause the program to crash.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: pos1 and pos2 which are two card positions, cards which is the list of 20 cards, the grid of cards

Outputs: updated grid with found pairs ""removed"" with empty spaces

Constraints: the grid must be a 5x4 grid, all cards must be present in the grid and only two card positions provided each round

Programming Concepts: Functions, nested lists, conditionals to check for a pair, loops to keep the game running, string manipulation to update position of card

Code Structure:

def create_grid(cards):
    # Create nested list with 5 lists each containing 4 elements 
    grid = [[... for i in range(4)] for j in range(5)]
    # Iterate over 20 cards and update them into the grid, two cards with the same symbol
    for card in cards:
        # Find empty position in grid
        empty_pos = ...
        # Update empty position in grid with card symbol
        ...

def get_symbols(grid, pos1, pos2):
    # Get symbol from position 1
    symbol_1 = ...
    # Get symbol from position 2
    symbol_2 = ...
    return (symbol_1, symbol_2)
  
def take_cards(grid, pos1, pos2):
    # Update position 1 with empty string
    ...
    # Update position 2 with empty string
    ...
    return updated_grid
    
def draw_grid(grid, pos1=None, pos2=None):
    # Clear the console
    ...
    # Iterate over 5x4 grid
    for i in range(5):
        for j in range(4):
            # Find out if position is same as either pos1 or pos2
            ...
            # If positions are same, display appropriate card symbol
            ...
            # Otherwise, display letter-digit combination
            ...
        # After every 4th card, add new line
        print('\n')
    # After iterating over 5x4 grid, start new line
    print('\n')
 
def main():
    # Shuffle cards
    ...
    # Create game grid
    ...
    # Set up round counter
    round_count = 0
    # While at least one card needs to be found
    while ...:
        # Draw game grid
        ...
        # Ask the user for two positions
        ...
        # Flip the two cards 
        symbols = ...
        # Increase round count 
        round_count += 1
        # Check if the symbols are the same 
        if symbols[0] == symbols[1]:
            # Take the cards 
            grid = ...
        # Otherwise cover the cards again
        ...
    # Once all pairs are found, output round count 
    print('You found all the pairs in %d rounds!' % round_count)
    # Ask if user wants to start a new game
    ...

if __name__ == '__main__': 
    main()",339,270,"{0: ""Input from players are not listed.""}",1,"KC,KH,KTC","functions,loops,string manipulation,variables,conditionals,lists","input/output handling,randomness,modules,exception handling,time",variables
7,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: In this task, the inputs are the contact book (represented as a list of dictionaries), a name (string), and the fields to be changed or added (dictionaries).

Outputs: The output of the function can vary based on which function is being used. If we are adding a contact, the output would be the contact book with an additional contact. If we are deleting a contact, it would be a contact book with one less contact. If we are editing a contact, the output will be the contact book with the existing information being updated. And, if we are listing or showing contacts, it will just be a list of names or information for a particular contact that is displayed in the console.

Constraints: The data should be consistent and valid.

Programming Concepts: This task requires us to use dictionaries and lists to represent contacts. We will need to be familiar with the basic operations of dictionaries and lists including creating, modifying, adding and deleting. We will also need to be aware of control flow statements such as conditional statements and loops. We would use if statements to determine which function to execute given the input parameters and loops to go through elements of a list.

Code Structure:
 def add_contact(contacts, name, **kwargs):
    contact[name] = kwargs
    contacts.append(contact)


def del_contact(contacts, name):
    for contact in contacts:
        if contact['name'] == name:
            contacts.remove(contact)
            return
    

def edit_contact(contacts, name, **kwargs):
    for contact in contacts:
        if contact['name'] == name:
            for key, value in kwargs.items():
                contact[key] = value
            return


def list_contacts(contacts):
    for contact in contacts:
        print(contact['name'])


def show_contact(contacts, name):
    for contact in contacts:
        if contact['name'] == name:
            for key, value in contact.items():
                print(key, ':', value)
            return",290,188,{},0: “Contact in add_contact not defined.”,"KC,KH,KTC","functions,loops,input/output handling,variables,conditionals,(args/kwargs) arguments,lists,dictionaries",,variables
7,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs: 
a) add_contact(…) - contact book, name, additional parameters 
b) del_contact(…) - contact book, name 
c) edit_contact(…) - contact book, name, fields to be changed 
d) list_contacts(…) - contact book 
e) show_contact(…) - contact book, name

Outputs: 
a) contact book 
b) names of contacts from contact book 
c) fields of contact from contact book 

Constraints: 
The contact must have a name and additional fields can be added.

Required Programming Concepts: 
Dictionaries, Lists, Functions 

Code Structure: 
def add_contact(contact_book, name, *params):
    ... 

def del_contact(contact_book, name): 
    ... 

def edit_contact(contact_book, name, fields):
    ... 

def list_contacts(contact_book): 
    ...

def show_contact(contact_book, name): 
    ... 

Explanation: 
Dictionaries: A dictionary is a data type in Python that stores key-value pairs. Each key represents a term that is being stored, and the value associated to a key is the information that is related to the key. For example, in the task, each contact will be represented as a dictionary, with the name being the key and the additional fields being the values associated to it. 

Example dictionary:
contact_dict = {'name':'John Smith', 'email':'john@gmail.com', 'address':'100 Main Street'}

Lists: A list is a data type in Python that stores a collection of items. In this task, a list will be used to store multiple contacts by creating a contact book with a list of multiple contact dictionaries. 

Example list:
contact_book = [
                  {'name':'John Smith','email':'john@gmail.com', 'address': '100 Main Street'},
                  {'name':'Bill Johnson', 'email':'bill@yahoo.com', 'address':'200 Main Street'}
               ]

Functions: A function is a block of code which will only run when it is called. It will take input values as parameters, process them, and return a value. In this task, different functions will be created to manipulate the contact book. 

Example function:
def add_contact(contact_book, name, *params):
    
    # Creates a new contact dictionary
    contact_dict = {}
    # Adds the name to the contact dictionary
    contact_dict['name'] = name
    # Iterates over the params and adds each one to the dictionary 
    for param in params: 
        contact_dict[param] = params[param]
    # Appends the dictionary to the contact book 
    contact_book.append(contact_dict)
    
    return contact_book",334,205,"{1: ""Outputs do not match functions.""}",0: “*params is confused with **kwargs in add_contact.”,"KC,KH,KTC","functions,lists,dictionaries,(args/kwargs) arguments","input/output handling,conditionals,loops",
7,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""For a contact or phone book, we represent contacts using dictionaries and combine them in a list to create a contact book. A contact consists of at least a name but can also include additional fields (such as email, address, date of birth, etc.).

Create a new Python module for this and implement the following functions:

a) add_contact(…)
This function takes the contact book as input and adds a new contact. The function must be passed a name and can also accept additional parameters to be added to the contact.

b) del_contact(…)
This function takes the contact book and a name as input. The person with the corresponding name is removed from the contact book.

c) edit_contact(…)
This function takes the contact book, a name, and the fields to be changed as input. Existing fields can be updated, and new information can be added to the contact.

d) list_contacts(…)
This function takes the contact book as input and lists the names of all contacts in the console.

e) show_contact(…)
This function takes the contact book and a name as input. It then displays all the stored data for that person in a formatted manner.

The above functions each take the contact list (and potentially additional parameters depending on the function) as input to modify the contact book accordingly or provide information.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: 
a) add_contact(…): contact book, name, and additional parameters 
b) del_contact(…): contact book, name 
c) edit_contact(…): contact book, name, fields to be changed 
d) list_contacts(…): contact book 
e) show_contact(…): contact book, name 

Outputs: 
a) add_contact(…): updated contact book 
b) del_contact(…): updated contact book 
c) edit_contact(…): updated contact book 
d) list_contacts(…): list of contacts in the console 
e) show_contact(…): all the stored data for that person in a formatted manner 

Constraints:
All functions must only take valid input and manage errors properly

Programming Concepts:
-Dictionaries: A data structure which stores data as key-value pairs
-Lists: A data structure which stores data as an ordered collection
-Functions: Blocks of code that are executed when they are called
-Modules: Blocks of code that are separate from the main program and can be imported and used elsewhere
-Parameters: The variables declared by the function

Code Structure: 
def add_contact(contact_book, name, **kwargs):
    """"""
    This function takes the contact book as input and adds a new contact. 
    The function must be passed a name and can also accept additional parameters to be added to the contact.
    """"""
    # code
 
def del_contact(contact_book, name):
    """"""
    This function takes the contact book and a name as input. 
    The person with the corresponding name is removed from the contact book.
    """"""
    # code
 
def edit_contact(contact_book, name, **kwargs):
    """"""
    This function takes the contact book, a name, and the fields to be changed as input. 
    Existing fields can be updated, and new information can be added to the contact.
    """"""
    # code
 
def list_contacts(contact_book):
    """"""
    This function takes the contact book as input and lists the names of all contacts in the console.
    """"""
    # code
 
def show_contact(contact_book, name):
    """"""
    This function takes the contact book and a name as input. 
    It then displays all the stored data for that person in a formatted manner.
    """"""
    # code",297,241,{},1,"KC,KH,KTC","functions,comments,(args/kwargs) arguments,modules,lists,dictionaries","input/output handling,conditionals,loops","comments,modules"
8,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Task: Rewrite the two mathematical functions (differences() and palindrome()) to either convert them into an iterative or recursive function to exhibit the same behavior as the original function.

Inputs: The input for the first function differences(values) is a list of numbers, while the input for the second function palindrome(word) is a string of any length.

Outputs: The output for the differences(values) function is a list of the differences between successive pairs in the input list. The output for the palindrome(word) function is either True or False, depending on whether the word is a palindrome.

Constraints: The rewritten functions must have the same behavior as the original functions and have the same input and output types.

Required Programming Concepts: The task requires knowledge of the basic principles of both recursive and iterative programming. 

Recursive programming: Recursive programming is a type of programming where a function calls itself with a modified set of input parameters until a certain condition has been met. The two conditions necessary for recursive programming to work are a base case and the ability for the current function to be modified in such a manner as to eventually bring the problem to the base case. 

Examples of recursive programming:

1) Fibonacci Sequence - A classic example of recursive programming:
def fibonacci(n):
  if n == 1 or n == 2:
    return 1
  return fibonacci(n-1) + fibonacci(n-2)
  
2) Factorial - Another classic example of recursive programming:
def factorial(n):
   if n <= 1:
     return 1
   else:
     return n*factorial(n-1)

Iterative programming: Iterative programming is a type of programming where a code is repeated until a certain condition has been met. Iterative programming usually requires the use of multiple loops and/or conditional statements.

Examples of iterative programming:

1) Fibonacci Sequence - An iterative implementation of the Fibonacci Sequence:
def iterativeFibonacci(n):
    a = 0
    b = 1
    for i in range(n):
        a, b = b, a + b
    return a

2) Factorial - An iterative implementation of the Factorial:
def iterativeFactorial(n):
    result = 1
    for i in range(n):
        result *= (i + 1)
    return result

Code Structure:

To convert the recursive function differences() into an iterative function:

def differences(values): 
  result = [] 
  i = 0 
  while i < len(values) - 1: 
    result.append(values[i+1] - values[i]) 
    i += 1 
  return result

To convert the iterative function palindrome() into a recursive function:

def palindrome(word):
  if len(word) == 0 or len(word) == 1: 
    return True 
  if word[0] != word[-1]: 
    return False 
  return palindrome(word[1:-1])",413,303,{},"0: ""Code structure wrong. Functions not converted.""","KC,KH,KTC","functions,loops,conditionals,lists,iteration/recursion",string manipulation,
8,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Task: Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function. The rewritten functions should exhibit the same behavior as the original function.

Inputs: Function (a) takes a list of numbers as a parameter. Function (b) takes a string of any length as a parameter. 

Outputs: Function (a) returns a list of numbers. Function (b) returns a boolean value (True or False). 

Constraints: Both functions must exhibit the same behavior as the original functions. 

Required Programming Concept: Recursion and Iteration.

Explanation of Recursion: Recursion is a method of programming or coding a problem which calls itself repeatedly until a halt condition is found. This is often done when there are several elements of a complex problem that can be broken down into a smaller, similar problem that can be solved. It is important when using recursion that there is a base case, or a condition where the recursion will stop.

Example of Recursion:

def print_list_recur(vals):
  if vals == []:
    return
  print(vals[0])
  print_list_recur(vals[1:])
  
print_list_recur([1, 2, 3, 4])

Output: 
1 
2 
3 
4 

In the above example, the initial list [1, 2, 3, 4] is passed in as the parameter for the recursive function print_list_recur. Within the function, the base case is checked to see if the parameter is an empty list (if vals == []). If the parameter is not an empty list, the function prints the first element of the list and calls the same function recursively with the remaining list (after the first element) [2, 3, 4] as the argument. This continues until the base condition is met, which prints all of the numbers in the list. 

Explanation of Iteration: Iteration is a method of programming or coding a problem in which a set of instructions are repeated until a specified condition is reached. An example of iteration would be looping. Looping is when a set of instructions are executed repeatedly until a certain condition is met.

Example of Iteration:

# Store input numbers 
nums = [2, 4, 6, 8, 10] 
  
# Iterating over the numbers 
for num in nums: 
  print(num) 

Output: 
2 
4 
6 
8 
10 

In the above example, an iterative solution is used to loop over a list of numbers. The for-loop iterates through the list “nums” and prints each value of the list until it reaches the end of the list. 

Code Structure: 

a) The function differences(values) takes a list of numbers as a parameter.

def differences_iterative(values): 
  result = [] 
  for i in range(len(values) - 1): 
    result.append(values[i+1] - values[i]) 
  return result

b) The function palindrome(word) takes a string of any length as a parameter.

def palindrome_recursive(word): 
  # Base case 
  if len(word) <= 1: 
    return True 
  # Recursive case 
  if word[0] != word[-1]: 
    return False 
  return palindrome_recursive(word[1:-1])",486,299,{},"0: ""Code structure wrong. Functions not converted.""","KC,KH","functions,loops,conditionals,lists,iteration/recursion",string manipulation,
8,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Analyze the two functions below and consider what they calculate. If it is a recursive function, convert it into an iterative function. If it is not a recursive function, convert it into a recursive function.

The rewritten functions should exhibit the same behavior as the original function.

a) The function differences(values) takes a list of numbers as a parameter.

	def differences(values):
		result = []
		for i in range(len(values) - 1):
			result.append(values[i+1] - values[i])
		return result

b) The function palindrome(word) takes a string of any length as a parameter.

	def palindrome(word):
		if len(word) <= 1:
			return True
		if word[0] != word[-1]:
			return False
		return palindrome(word[1:-1])""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Task: Rewrite the functions differences(values) and palindrome(word) to either use recursion or iteration, depending on their original behavior.
Inputs: For differences(values), input is a list of numbers. For palindrome(word), input is a string.
Outputs: For differences(values), output is a list of numbers. For palindrome(word), output is a boolean.
Constraints: The rewritten functions must exhibit the same behavior as the original functions. 
Required programming concepts: Iteration (loops) and recursion. 

Code Structure: 

def differences(values):
    ...
def palindrome(word):
    ...

Explanation of Iteration:

Iteration is a programming concept that is used to perform a task multiple times. This can be done using a looping construct, such as a while loop, for loop, or do-while loop. For example, the following code is a for loop that will print the numbers 0-9: 

for i in range(10):
    print(i)

This loop will run 10 times, and each time it runs, the variable i is set to a number from 0-9. 

Explanation of Recursion:

Recursion is a programming concept where a function calls itself, and uses some condition to end the call. This can be used to solve problems where the task can be broken down into smaller tasks. For example, the following code is a recursive function that will calculate the factorial of a number: 

def factorial(n):
    if n == 0: 
        return 1
    else:
        return n * factorial(n-1)

This function will call itself, and then use the condition n == 0 to stop the calls. Each time the function is called, the value of n is reduced until it reaches 0, at which point the function returns 1.",271,162,{},1,"KC,KH","functions,loops,iteration/recursion,conditionals","string manipulation,lists",
9,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs: 
A natural number n which represents the dimension of the matrix (e.g. 4)

Outputs:
1. The two-dimensional list representing the random matrix.
2. The minimum cost of the optimal path from top-left (0,0) to bottom-right (n,n)
3. The sequence of fields representing the optimal path

Constraints:
- The matrix contains only integers between 0 and 9.
- Each field can only be visited once on a path.
- From a field, only the horizontally and vertically neighboring fields can be visited.

Programming Concepts:
1. Create a function: A function is a piece of code made of one or more instructions that performs a specific task. In our task, we are asked to create a function that takes a parameter n and returns the two-dimensional list representing the random matrix. 

2. Recursive function: A recursive function is a function that calls itself, which can be used for solving problems that can be divided into sub-problems. For our task, we are asked to create a recursive function that calculates the optimal path from top-left (0,0) to bottom-right (n,n), meaning our recursive function needs to call itself in order to continuously update the path with the lowest cost until we reach the destination.

3. Mark fields: We need to mark already visited fields within the matrix in order to avoid revisiting them (for example, using the value math.inf or -1). 

4. Copy module: We need to use the copy module for copying the matrix, as lists are mutable and this can cause issues if we modify the matrix within the function.

Code Structure:

def generate_matrix(n):
    # Generate random matrix with dimension n and values in the range of 0 to 9

def optimal_path(matrix):
    # Calculate the minimum cost of the optimal path from the top-left (0,0) to the bottom-right (n,n)

def mark_fields(x,y,path,matrix):
    # Mark fields using math.inf or -1

def copy_matrix(matrix):
    # Copy the matrix

def main():
    n = <input number>
    matrix = generate_matrix(n)
    cost, path = optimal_path(matrix)
    copy_matrix(matrix)
    mark_fields(x,y,path,matrix)
    
if __name__ == ""__main__"":
    main()",354,288,{},1,"KC,KH,KTC","functions,randomness,modules,lists,iteration/recursion","conditionals,loops",
9,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs:
- n: natural number (dimension of the matrix)
- matrix: two-dimensional nested list

Outputs:
- minimum costs
- corresponding optimal path

Constraints:
- Each field can only be visited once on a path. 
- From a field, only the directly neighboring fields can be visited (only horizontally and vertically). 

Programming Concepts:
- Recursion 
- Loops
- Modifying the matrix (nested lists are mutable)
- Copy module
- Comparing costs from neighboring fields

Code Structure:

# Create matrix
def create_matrix(n):
    # Create empty matrix
    matrix = []

    # Fill matrix with random values
    for row in range(n):
        row = []
        for col in range(n):
            row.append(random.randint(0, 9))
        matrix.append(row)
    return matrix

# Calculate optimal path
def find_optimal_path(matrix, start):
    # Mark already visited fields in matrix
    # Base case
    # Recursive case
    # Compare minimum costs from neighboring fields
    # Return minimum costs and optimal path
    pass",131,97,{},1,"KC,KH,KTC","functions,loops,randomness,modules,lists,iteration/recursion",conditionals,
9,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""For a square matrix (n x n), we want to calculate the most cost-effective path from the top-left corner to the bottom-right corner. The elements of the matrix (integers from 0 to 9) represent the respective costs of each field. The cost of a path corresponds to the sum of the costs of all visited fields.

Constraints:
	- Each field can only be visited once on a path.
	- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).
	- The matrix is represented by a two-dimensional nested list.
	- The matrix contains only integers in the range of 0 to 9.

Here's a small example:

[[4, 0, 8],
[3, 4, 7],
[8, 0, 7]]

We start at the top-left position (0, 0). The initial cost is 4. If we go right, we add 0 to the cost. Then we go down twice (+4 and +0) and finally to the right (+7) to reach the destination. The total cost of this path is: 4 + 0 + 4 + 0 + 7 = 15.
The path itself is described by the sequence of visited fields:
[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]

a) Creating the Matrix:
Implement a function that takes a natural number n as a parameter, which represents the dimension of the matrix. The function should return a matrix (nested list) with random values from the mentioned value range.

b) Finding the Optimal Path:
Implement a recursive function that receives a matrix as a parameter and calculates the (global) optimal path, i.e., the path with the lowest costs, to walk from the top-left (0, 0) to the bottom-right (n, n). The function should return both the minimum costs and the corresponding optimal path.
Hints:
	- To find the optimal path from the current field, compare the minimum costs from the neighboring fields.
	- To avoid revisiting already visited fields, you can mark them within the matrix. For example, using math.inf or -1.
	- If you modify the given matrix within the function, keep in mind that lists are mutable and consider the potential ""issues"" this can cause. The copy module can be helpful in this case. Documentation: https://docs.python.org/3/library/copy.html
	- It might be useful to provide an additional optional parameter for the starting position.
	- Test the function initially with small matrices, as the calculations can otherwise take a very long time.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: 
- n (natural number representing the matrix dimensions)

Outputs:
- Matrix with random values from the given values range 0 to 9
- Minimum costs of the optimal path 
- Optimal path (sequence of visited fields)

Constraints: 
-Each field can only be visited once on a path. 
- From a field, only the directly neighboring fields can be visited (only horizontally and vertically).

Required Programming Concepts: 
-Loops
-Conditions (If/Else)
-Recursion
-Data structures (2D array/ list)
-Math module 
-Copy module

Code Structure (No Solution):

#Creating the Matrix:
def create_matrix(n): 
    pass

#Finding the Optimal Path:
def find_optimal_path(matrix): 
    pass",95,67,{},1,"KC,KH,KTC","functions,loops,conditionals,modules,lists,iteration/recursion",randomness,
10,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Task: Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

Inputs: Text from given file

Outputs: All character strings between < and >; all (year) numbers between 1900 and 2099

Constraints: Must use Python for the code; must use regular expressions (re)

Programming concepts: Loops; regular expressions (re)

Code Structure:

# Import re module 
import re 

# Read from given file 
with open(<filename>, 'r') as f:
    text = f.read() 

# Create regex pattern 
pattern_<> = re.compile(<regex pattern>)
pattern_year = re.compile(<regex pattern>)

# Find all character strings between < and >
matches_<> = pattern_<>.finditer(text)
for match in matches_<>:
    <aceess the match and print results>

# Find all year numbers between 1900 and 2099
matches_year = pattern_year.finditer(text)
for match in matches_year:
    <aceess the match and print results>

Explanation of concepts: 

Loop: A loop is a type of control flow statement in programming used to when a repeated set of instructions needs to occur. In Python, this is accomplished with a while or for loop. For example, to loop through a list of ten items, you could use the following code block: 

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
for item in my_list: 
    print(item) 

This would print the numbers 1-10 to the console. 

Regular Expressions (re): Regular expressions are a sequence of characters that are used to match pieces of text according to certain patterns. The re module in Python is used to work with regular expressions. For example, the following code block uses the re.search() function to check if a given string begins with the word “Hello”: 

import re 
my_string = 'Hello world!' 
if re.search('^Hello', my_string): 
    print('The string begins with ""Hello""')

The code prints “The string begins with “Hello”” if the my_string variable starts with the word “Hello.”",309,170,{},1,"KC,KH,KTC","loops,regex,file i/o",,loops
10,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Inputs: Text from a given file

Outputs: All character strings located between < and the next >; all numbers between 1900 and 2099

Constraints: None

Required programming concepts: Regular expressions

Code structure: 

# Import the re (regular expression) module
import re

# Open the text file containing the source text
file = open(""input.txt"")

# Initialize an empty list to store the outputs
result = []

# Loop through each line of the text file
for line in file:

  # Use regular expression to search for character strings located between < and >,
  # and save the matches in the result list
  result += re.findall(r""<[^>]*>"", line)

  # Use regular expression to search for numbers between 1900 and 2099, 
  # and save the matches in the result list
  result += re.findall(r""(19|20)\d{2}"", line)
 
# Print the results
for each in result:
  print(each)

Explaining the concepts: 
Regular expressions (re): Regular expressions are a type of programming language used to match patterns in text. They use a set of special symbols and text-matching shortcuts to identify strings of characters within a body of text. For example, the regex pattern ""\w"" is a shortcut that matches any single alphanumeric character (number or letter). For the course of this task, regular expressions will be used to search the text file for character strings and year numbers. 

findall() method: The findall() method is used in the re module to locate all matches of a pattern in a string. The syntax for the findall() method is as follows: findall(pattern,string,flags=0). The pattern parameter is a regular expression that specifies what characters should be matched and the string parameter is the source string that is to be searched. The flags parameter is used to modify the behavior of the regular expression. For the task at hand, the flags parameter is optional and not used. 

\w: Matches any single alphanumeric character (number or letter).

\d: Matches any single decimal digit (0-9).

(19|20): Matches either 19 or 20.

\d{2}: Matches any two consecutive decimal digits.


[^>]*: Matches any character that is not a > symbol, zero or more times.",345,194,{},1,"KC,KH,KTC","loops,regex,file i/o",,loops
10,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Create Python code that reads the text from a given file and uses regular expressions (re) to extract the following elements and outputs them on the console.

a) All character strings that are located between < and the next >. The opening < and closing > should also be included in the output. Example: <a>, <span ...>.

b) All (year) numbers between 1900 and 2099.

Documentation for the re module: https://docs.python.org/3/library/re.html""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"INPUTS: The file to be read with text content.
OUTPUTS: Character strings that are located between < and the next > and all (year) numbers between 1900 and 2099.
CONSTRAINTS: The use of the re module.

PROGRAMMING CONCEPTS:

1. File handling: This involves reading the content of the given file as input and manipulating it accordingly.

2. Regular Expressions: A sequence of characters that forms a search pattern used to match characters in a string or a file.

EXAMPLE OF FILE HANDLING:

# Open the file 
f = open('file_name.txt', 'r') 
  
# read all lines in the file 
lines = f.readlines() 
  
# close the file after reading the lines. 
f.close() 

# Use loop to iterate through each line in file 
for line in lines: 
  
    # process the line 
    # do something with line
    
EXAMPLE OF REGULAR EXPRESSIONS:
import re

#pattern to match
pattern = 'word'

#text to search
text = 'this is a word'

#search the pattern in text
if re.search(pattern,  text):
    print('Match Found')
	
CODE STRUCTURE: 
#import re module
import re

#open the file 
f = open('file_name.txt', 'r') 

#read all lines in the file 
lines = f.readlines() 
  
#close the file after reading the lines. 
f.close()

#Use loop to iterate through each line in file 
for line in lines: 
  
    # execute the regex for <> 
    characters = re.findall('<.*?>', line)

    # execute the regex for years 
    years = re.findall('[1-2][09][0-9][0-9]', line)

    #display the characters and years found
    print('characters: ', characters)
    print('years: ', years)",240,122,{},1,"KC,KH,KTC","loops,input/output handling,regex,file i/o",,
11,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Task: Implement a game as described below:

Inputs: deck of 52 cards (13 * 4 suits), number of players

Outputs: number of rounds, winners of the rounds, winners of the game

Constraints: no duplicate cards, compare card values following criteria, account for trump suit, and provide robust user interface

Required Programming Concepts: creating and manipulating data structures, looping structures,random selection, functions (passing and returning values), conditionals, user input, user output (console). 

Code Structure:

// Define global variables 

// Create function create_cards()

// Create function deal_cards()

// Create function compare_cards()

// Create function to determine winner based on most tricks won or most rounds won

// Create function to program game flow using functions previously defined

// Create function to create computer opponent

// Create function to program console-based user interface 

// Call created functions in try-except block

// Create/call main function 


Detailed explanation of concepts: 
Data Structures: Data structures are structures that contain data and methods used to manipulate and organize data. Examples of data structures include arrays, strings, lists, dictionary, sets, and classes (Python). 

Looping Structures: Looping structures are used to iterate through collections of elements. The most common looping structures are for-loops and while-loops. For example, to iterate through a list, you can use a for-loop that iterates through the elements of the list until the last element is accessed.

Random Selection: Random selection involves selecting random elements from a set of elements. In Python, the random module provides access to functions that generate random numbers. For example, the random.choice() function chooses an element from a list at random.

Functions (Passing and Returning Values): Functions are pieces of code which accept inputs (parameters) and produce outputs (return values). When passing values to a function, arguments are passed either by position or keyword. When returning values from a function, the return statement is used.

Conditionals: Conditionals are structures that allow you to execute code based on the evaluation of an expression. Common conditional operators used in programming are if, else, and else if.

User Input: User input involves gathering data from the user. In Python, the input() function allows the user to type in a value and stores it as a string.

User Output (Console): User output in Python involves displaying text or data to the console. The print() function is most commonly used to display data.

Try-except Block: A try-except block is a control structure that catches any errors that might occur while executing code. If an error occurs, the code in the except block is executed.

Main Function: The main function is the entry point of a program. Any code you want to execute when the program starts should be placed in the main function. The main function is called at the end of the program.",458,270,"{0: ""Player input is missing."", 1: [""Indication of which player's turn it is during the game is missing"", 'Feedback to the user about valid inputs is missing']}",1,"KC,KH,KTC,KMC","functions,loops,input/output handling,variables,conditionals,randomness,exception handling,lists",dictionaries,"functions,variables,randomness"
11,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Task: Create a game of cards for 2-5 players where the game ends when a certain number of rounds have been completed.

Inputs:
 - The deck of 52 cards (13 * 4 suits).
 - Number of players.

Outputs: 
 - The winner of the game.
 
Constraints: 
 - The game must end when a certain number of rounds have been completed, which is calculated using the formula: Number of rounds = floor(Total number of cards / Number of players).
 
Programming Concepts: 
 - Data structures: Data structures are collections of data that are organized to allow efficient access and modification. In order to represent the cards in this game, a list, set, or dictionary could be used. Each item in the data structure should contain the information required to describe each card. 
 - Control flow: Control flow consists of instructions or functions that determine how data is processed. For example, when dealing the cards, the code should use a loop (eg. for) to process each of the cards in the list. 
 - Functions: A function is a set of instructions that take an input and returns an output. The task requires a number of functions to be created, such as create_cards(), deal_cards(), compare_cards(), etc. 
 
Code Structure: 
 - Create a data structure to represent the 52 cards.
 - Define a function to create the deck of cards.
 - Define a function to determine the number of rounds to play. 
 - Define a function to determine the trump suit. 
 - Define a function to deal the cards.
 - Define a function to compare the cards. 
 - Define a function to select the winner. 
 - Define a function to create a computer opponent.
 - Define a function to create the user interface. 
 - Create a loop to run for the specified number of rounds. 
 - Create a loop to end the game when certain conditions are met.
 - Print the results.",295,225,"{0: ""Player input is missing."", 1: [""Indication of which player's turn it is during the game is missing"", 'Feedback to the user about valid inputs is missing']}",1,"KC,KH,KTC,KMC","functions,loops,input/output handling,conditionals,lists,user interface design","dictionaries,exception handling","functions,user interface design"
11,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""Implement a game as described below:

- The game is played with a deck of 52 cards (13 * 4 suits).
- The game can be played with 2-5 players.
- A starting player and an order of play are determined.
- A certain number of rounds are played (depending on the number of players). The number of rounds is calculated using the formula:
	Number of rounds = floor(Total number of cards / Number of players)
- Each round proceeds as follows:
	1. Each player is dealt cards (the number of cards corresponds to the round number). In the first round, each player receives one card, in the second round each player receives two cards, and so on.
	2. The trump suit for the round is determined by making a random selection.
	3. The game is played for tricks. The number of tricks is equal to the number of cards in hand. The following rules apply for playing a trick:
		i. Each player plays a card in turn (starting with the starting player). The player with the highest-ranking card wins the trick.
		ii. The next player in order takes the lead for the next trick.
	4. At the end of the round, all cards are collected, shuffled, and a new round begins with the next player in the order as the starting player.
- Determining the winner:
	Choose one variant for the winning condition:
		a) Most tricks won.
		b) Most rounds won.
- Implement basic functions:
	a) Create a function create_cards() that returns a list of cards. The cards should be represented using a dictionary. Consider how you want to represent the cards internally. The cards should correspond to a standard deck with 2, ..., 10, Jack, Queen, King, Ace, and the 4 suits (Clubs, Spades, Hearts, Diamonds).
	b) Create a function deal_cards() that simulates dealing the cards to the players. The function should receive the cards as a list, the number of players, and the number of cards for each player as input. The function should return a tuple containing the cards for each player in a list.
	c) Create a function compare_cards() that handles card comparisons. It should be possible to pass any number of cards for comparison. The function should return the index of the highest-ranking card, taking the value of the suits into account. The comparison of cards should follow the following criteria:
		i. A card of the trump suit is always higher-ranking than cards of other suits. For example, if the trump suit is Diamonds, the Diamond 2 is higher-ranking than the Club 3.
		ii. The suits (Clubs, Spades, Hearts, Diamonds) are sorted in descending order. That means Clubs are higher-ranking than Spades. In case of equal card values, the suit decides.
	d) Now, program the game flow using the previously defined functions.


Additional requirements and hints:
- Create a computer opponent that can perform actions for players defined as computer opponents (e.g., a very simple one - random or a ""smarter"" one).
- Develop a simple console-based user interface that can be controlled by keyboard input and guides the user through the program, offering at least the following possibilities:
	1. Inform the user at the beginning about valid inputs and their effects.
	2. Indicate which player's turn it is.
	3. Allow the user to end the game or start a new round.
	4. Design your user interface to be robust, so that incorrect user inputs do not lead to a crash.
- Structure your implementation by creating additional functions.""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: 
1. Cards for each player (in dictionary form) 
2. Number of players 
3. Knowledge of the rules of the game 

Outputs: 
1. The winner 
2. The number of rounds played 

Constraints: 
1. The total number of cards must be divisible by the number of players 
2. Different rules may apply, depending on the variant chosen 

Required programming concepts: 
1. Variables - Variables refer to a memory location where data can be stored, which can then be used to display data or perform calculations. The syntax for declaring variables is <data type> <variable name> = <value>; 
2. Mathematical operations - Mathematical operations allow us to perform arithmetic calculations such as addition, subtraction, multiplication, and division. This can be used in the calculation of the number of rounds to be played in the game. 
3. Data types - This refers to the type of values a variable can hold. Common data types include integers, decimals, strings, and Booleans. 
4. Control Flow - Control flow refers to the order in which instructions are executed. In programming, control flow is represented by if-else statements, switch statements, while and do-while loops, and for loops. This allows for decisions and operations to be performed based on certain conditions. 
5. Modules - Modules are self-contained blocks of code that can be reused or imported from other programs. For example, the random module provides functions that allow the program to generate random numbers or select from a given list. 

Code structure: 
1. Create an array of the cards: 
  a. Declare an array of dictionaries 
  b. Populate the array with card data 
2. Create a game loop to allow users to play the game: 
  a. Prompt user to enter the number of players 
  b. Calculate the total number of rounds based on the entered number of players 
  c. Iterate over the rounds and within the rounds iterate over the players 
3. Create a trump suit selection method to select a suit: 
  a. Generate a random sprite from the array of suits 
  b. Set generated sprite as trump for the round 
4. Create a card dealing method to determine the cards for each player: 
  a. Receive number of cards and list of cards as input 
  b. Generate list of cards for each player based on the number of cards in the round 
  c. Distribute the cards to the players from the list 
5. Create a method to compare the highest-ranking card and determine the winner of the trick: 
  a. Receive list of cards as input 
  b. Compare the suits of the cards and assign a rank to each card 
  c. Find the highest-ranking card 
6. Create a method to calculate the winner of the game: 
  a. Receive result of each round as an input 
  b. Count the number of tricks or rounds won by each player 
  c. Determine the winner based on the selected variant 
7. Create a computer opponent to complete the user interface 
  a. Receive computer player's input as an input 
  b. Based on the input, use if-else statements to determine the computer opponent's action 
8. Create a user interface to guide users through the game 
  a. Receive user input through the console 
  b. Create if-else statements to handle different user inputs 
  c. Prompt the user for further input 
  d. Use a while loop to loop until the game is over 
9. Test implementation 
  a. Run program and enter different inputs to test user interface 
  b. Enter different numbers of players to test calculation of number of rounds 
  c. Use different card combinations to test the comparison of cards 
  d. Use different inputs to test the computer opponent",604,423,"{0: ""Player input is missing."", 1: [""Indication of which player's turn it is during the game is missing"", 'Feedback to the user about valid inputs is missing'], 2: ""Number of cards must not be divisible by player number.""}",1,"KC,KH,KTC,KMC","functions,loops,variables,conditionals,randomness,modules,lists,user interface design,dictionaries","input/output handling,exception handling","functions,variables,randomness,modules,user interface design"
12,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",1,"Inputs & Outputs: The inputs include the initial settings, such as the size of the habitat, the types of plants and organisms, and the rules governing the various aspects of the ecosystem. The outputs include a visualization of the state of the ecosystem after each round, based on the rules that are implemented.

Constraints: In order to provide a realistic representation of the ecosystem, there should be at least three (3) different types of plants and at least three (3) classes of organisms. The user should also be able to control the speed of the simulation.

Programming Concepts:
Object-oriented Programming (OOP): OOP is a programming paradigm that uses classes and objects to model different entities of the problem domain as objects. Each object is an instance of a class which defines the attributes and behavior of the objects. 

Classes: A class is a blueprint that defines the attributes and behavior of objects belonging to that class. 

Objects: Objects are instances of classes that encapsulate properties and behaviors specific to them.

Inheritance: Inheritance is a mechanism by which a derived class (or ""child"" class) can inherit the attributes and behavior from its parent class (or ""parent"" class). This allows for the reuse of code and abstraction of complex logic.

Encapsulation: Encapsulation is an OOP principle that allows for the bundling of data and methods (functions) that operate on that data. By abstracting the objects from the outside world, we can create a reusable and maintainable code base.

Polymorphism: Polymorphism is the ability of different classes to have different behavior for the same method so that different objects can have different implementation of the same subclass method.

Data Abstraction: Data abstraction is a technique of separating the public and private aspects of an object by providing only the necessary public data and hiding the private data from the user. This leads to simpler and more maintainable code.

Randomness: Randomness is a way of modeling unpredictable behavior. Generally, all the inputs and outputs of a program are known beforehand, but randomness can be used to generate unexpected and interesting outcomes.

Code structure:
Class Ecosystem:
	- Attributes: size, plants, organisms
	- Methods: 
		- __init__() 
		- simulate_round() 
		- regenerate_plant() 
		- find_food()
		- hunt() 
		- increase_hunger()
		- maintain() 
Class Plant:
	- Attributes:  min_size, max_size
	- Methods:
		- __init__() 
		- growth() 
		- check_hunger()
Class Organism: 
	- Attributes: hunger_level, food_required
	- Methods:
		- __init__() 
		- search_food()
		- reproduce() 
		- increase_hunger()
		- die()
Main: 
	- Setup the environment 
	- Prompt user for initial settings 
	- Initialize the organisms 
	- Begin the simulation 
	- Iterate over rounds of simulation 
		- Call the Ecosystem.simulate_round() 
		- Generate visual representation of the environment 
		- Prompt for user input 
	- Terminate the program when simulation is complete.",424,268,{},1,"KC,KH,KTC","class inheritance,randomness,method overriding,OOP,user interface design","exception handling,input/output handling",
12,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",2,"Task: Implement an ecosystem using object-oriented programming. 
Inputs: User data (habitat specifications, types of plants and organisms). 
Outputs: Ecosystem simulation (rounds, organisms, plants, available food). 
Constraints: Rules for organism growth, reproduction, propagation, death, and plant size, user data input. 

Programming concepts: 
Object-Oriented Programming (OOP): OOP is a type of programming that uses objects and tries to represent the real-world through programming. OOP is based on classes and objects. Classes are the blue-prints of the objects which define their properties (data) and methods (actions). Object-oriented programming is used to make code more organized, efficient, and reusable. 

Example: 
class Animal: 
  def __init__(self, name, age): 
    self.name = name 
    self.age = age 
 
  def eat(self): 
    print(f""{self.name} is eating"")

Code Structure: 
1. Create classes to represent the plants, organisms, and habitat. 
2. Create the methods to represent activities for the plants and organisms such as eating, reproducing, growing, and fading. 
3. Create the environment class and methods that represent the habitat and its interaction with the plants and organisms such as providing food, controlling the population, describing the size of the habitat, etc. 
4. Write a method to represent the rounds and the activities performed in them. 
5. Create a user interface (console-based) to prompt user input, provide the user with a representation of the current state of the simulation, provide options to pause or run multiple rounds, and robustly handle user inputs. 
6. Create any additional rules as mentioned in the task. 
7. Consider implementing any of the additional aspects that use randomness. 
8. Test and debug the code.",265,193,"{0: ""Input for pausing is missing."", 2: 'Randomness is missing.'}",1,"KC,KH,KTC,KMC","functions,OOP","class inheritance,method overriding,randomness,user interface design,exception handling,input/output handling",functions
12,"Explain the following task, identify the inputs and outputs, any constraints,  the required programming concepts and give a code structure (no solution): 
""
Implement an ecosystem using object-oriented programming. The ecosystem exists within a habitat, where various organisms such as herbivores, omnivores, carnivores, and plants live.

	- A plant requires space in the habitat. When creating a habitat, the size and other properties should be initialized.
	- The number of organisms that can live in the habitat depends on the available food. Organisms can eat other organisms or plants, and they can also die.

Here are some basic rules:
	- The ecosystem should be simulated in rounds. In each round, organisms should grow, reproduce, and propagate. Animals need to continue feeding to avoid starvation. Organisms can die due to diseases, injuries, being eaten, lack of food, or old age.
	- In a habitat, organisms and plants coexist. Plants need a certain amount of space to grow and reach their full potential.
	- There should be at least three (3) different types of plants in a habitat. Each plant has its advantages and limitations. A plant has a minimum and maximum size. If a plant is eaten more than its minimum size allows, it dies.
	- There should be at least three (3) different classes of organisms (herbivores, omnivores, and carnivores) in the habitat. Each organism searches for food, which can be more or less successful. If an organism finds too little food, it dies. Carnivores and omnivores can also hunt. The success of a hunt depends on the situation and can sometimes be dangerous.

Additional properties:
	- Each round corresponds to a certain unit of time, which you can define (depending on the unit of time and the organism, not all activities such as reproduction need to occur every round).
	- Each round, the plants regenerate to a certain extent. The regeneration rate depends on the plant species.
	- Each organism should have enough food for a certain period of rounds. The required amount of food can vary between organisms. If an organism doesn't find enough food, it becomes weaker and eventually dies.

Tasks:
	- Define at least 5 additional rules that expand or modify the above rules. For example, eucalyptus can only be eaten by koalas, or what happens when the habitat is full and no more plants can grow? There can also be plants that grow on trees and do not require additional habitat space. Instead of dying, animals can enter a state of rest (hibernation) instead of dying immediately. Note: If possible, the rules should be implemented by overriding the corresponding methods in the superclass.
	- Different aspects (at least 2) should depend on randomness. This can include the success of a hunt or the strength of plant growth (as a weather influence), for example.

User Interface:
	- Create a console-based user interface that prompts the user for initial settings. After the ecosystem is activated, no further user intervention should be necessary (although it can be available for debugging or testing purposes).
	- Provide the option to pause the ecosystem or simulate multiple rounds after activation.
	- Consider how to provide the user with a clear representation of the state of the ecosystem after each round. Implement different modes that adjust the simulation speed, allowing multiple rounds to run without requiring user input or interaction.
	- Ensure that user inputs are clear and robust, meaning the program should not crash in case of incorrect input.


Note: There are many options and freedoms in implementing this project. Start with a simple approach first and remember that it can always be made more challenging!""

Acting as a teacher give for each concept a detailed explanation with examples tocreate a foundation to solve the task.",3,"Inputs: Initialization of habitat size and other properties; User prompts for initial settings
Outputs: Current state of the ecosystem; Debugging and test results
Constraints: Size and nature of habitat; Amount of food available; Different classes of organisms
Programming Concepts: Object-oriented programming; Inheritance; Randomness; Methods overriding; Console-based user interface; Class attributes; Exception handling 
Code Structure: 
1. Define a base class called Ecosystem.
2. Create separate classes for Herbivores, Omnivores, and Carnivores (all should inherit the Ecosystem class).
3. Define the variables needed for simulations such as habitat size, food supplies, etc.
4. Define methods such as grow(), reproduce(), and propagate(), and override the same in the subclasses as needed.
5. Initialize the habitat size through user prompt.
6. Allow users to pause or choose simulation speed.
7. Implement method to print the current state of the ecosystem.
8. Catch any invalid input with exception handling.",146,91,"{0: ""Input for pausing is missing."", 2: 'The constraint regarding the need for at least 5 additional rules not explicitly mentioned.'}",1,"KC,KH,KTC,KMC","functions,loops,input/output handling,method overriding,OOP,variables,randomness,class inheritance,exception handling,user interface design",,"functions,loops,variables"
